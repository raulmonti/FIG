/*
 * Two-nodes queueing network for the FIG tool
 * Budde | 2019
 *
 * {-
 * Jackson tow-nodes network:
 * 
 *     ____TO________
 *  F |   n0 n1 | out|  Probabilities
 *  R |n0 .1 .6 | .3 |  transition-matrix
 *  O |n1 .5 .3 | .2 |  of the two nodes
 *  M +---------+----+
 *
 * Both nodes have assumed infinite capacity
 * New packets arrive and can leave from both nodes ("in parallel"):
 *  - external arrivals follow an exponential distribution with rate 1
 *  - a packet served in node i (at rate mu_i) makes a probabilistic choice:
 *    --> with probability 0.2 it leaves the system
 *    --> with the probabilities of the transition-matrix it goes to another node
 * Overall arrival rate at nodes: n0=l_a, n1=l_b
 * Service rates of the nodes: n0=mu_a < n1:mu_b
 * Loads of the nodes: n0=rho_1 > n1=rho_b
 * The 'load' of node i is: (1+in_from_other_nodes)/mu_i == l_x/mu_x
 *
 * Rare events: target node n1 reaching a predefined limiting capacity 'L'
 * Stopping events (for transient analysis): n1 becoming empty
 * Initial state: n0=0, n1=1
 * 
 * NOTE: for the event to be rare and interesting
 *       it is important that lower-number nodes have heavier loads,
 *       i.e. rho_a > rho_b ("earlier nodes serve packets slowlier")
 *
 * NOTE: this model was inspired in the 7-nodes queueing network
 *       in "RESTART vs. Splitting: A comparative study," by
 *       Jose Villen-Altamirano. Performance Evaluation 121-122 (2018)
 * -}
 */

const int L = 11;    // Queue limiting capacity
const int C = 2*L;   // Queues real capacity (mimic infinite size)
const int mu_a =  9;
const int mu_b = 14;
const float mu0 = mu_a;  // service rate in Node0
const float mu1 = mu_b;  // service rate at Node1
const float l_a = 4.5;
const float l_b = 5.73;
const float l0 = l_a;    // overall arrival rate at node n0 --> NOT USED!
const float l1 = l_b;    // overall arrival rate at node n1 --> NOT USED!

// Transition matrix probabilities:
// column 1:
const float p0_0 = 0.1;
const float p1_0 = 0.5;
// column 2:
const float p0_1 = 0.6;
const float p1_1 = 0.3;
// column out:
const float p0_2 = 0.3;
const float p1_2 = 0.2;


module Node0
	n0:    [0..C];
	dest0: [0..2];  // 0=self  1=Node1    2=out
	todo0: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr0: clock;  // extern arrival ~ exponential(1.0)
	c_ser0: clock;  // packet service ~ exponential(mu0)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr0 -> (todo0'=1) & (c_arr0'= exponential(1.0));
//	[n0_n0?]    -> (todo0'=1);  // self-loop
	[n1_n0?]    -> (todo0'=1);
	[arr0!!] todo0==1 & n0 == 0     -> (todo0'=2)
	                                 & (n0'=n0+1)
	                                 & (c_ser0'=exponential(mu0));
	[arr0!!] todo0==1 & n0>0 & n0<C -> (todo0'=0)
	                                 & (n0'=n0+1);
	[arr0!!] todo0==1 & n0 == C     -> (todo0'=0);
	// Choose next packet destination
	[choose0!!] todo0==2 -> p0_0 : (dest0'=0) & (todo0'=0)
	                      + p0_1 : (dest0'=1) & (todo0'=0)
	                      + p0_2 : (dest0'=2) & (todo0'=0);
	// Packet service
	[n0_n0!] n0>0 & dest0==0 @ c_ser0 -> (todo0'=2)  // self loop
	                                   & (c_ser0'=exponential(mu0));
	[n0_n1!] n0>0 & dest0==1 @ c_ser0 -> (todo0'=3);
	[n0_  !] n0>0 & dest0==2 @ c_ser0 -> (todo0'=3);
	[dep0!!] todo0==3 & n0 <= 1 -> (n0'=0)
	                             & (todo0'=0);
	[dep0!!] todo0==3 & n0  > 1 -> (n0'=n0-1)
	                             & (todo0'=2)
	                             & (c_ser0'=exponential(mu0));
endmodule

module Node1

	n1:    [0..C] init 1;
	dest1: [0..2];  // 0=Node0 1=self     2=out
	todo1: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr1: clock;  // extern arrival ~ exponential(1.0)
	c_ser1: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr1 -> (todo1'=1) & (c_arr1'=exponential(1.0));
	[n0_n1?]    -> (todo1'=1);
//	[n1_n1?]    -> (todo1'=1);  // self-loop
	[arr1!!] todo1==1 & n1 == 0     -> (todo1'=2)
	                                 & (n1'=n1+1)
	                                 & (c_ser1'=exponential(mu1));
	[arr1!!] todo1==1 & n1>0 & n1<C -> (todo1'=0)
	                                 & (n1'=n1+1);
	[arr1!!] todo1==1 & n1 == C     -> (todo1'=0);
	// Choose next packet destination
	[choose1!!] todo1==2 -> p1_0 : (dest1'=0) & (todo1'=0)
	                      + p1_1 : (dest1'=1) & (todo1'=0)
	                      + p1_2 : (dest1'=2) & (todo1'=0);
	// Packet service
	[n1_n0!] n1>0 & dest1==0 @ c_ser1 -> (todo1'=3);
	[n1_n1!] n1>0 & dest1==1 @ c_ser1 -> (todo1'=2)  // self loop
	                                   & (c_ser1'=exponential(mu1));
	[n1_  !] n1>0 & dest1==2 @ c_ser1 -> (todo1'=3);
	[dep1!!] todo1==3 & n1 <= 1 -> (n1'=0)
	                             & (todo1'=0);
	[dep1!!] todo1==3 & n1  > 1 -> (n1'=n1-1)
	                             & (todo1'=2)
	                             & (c_ser1'= exponential(mu1));
endmodule


properties
	S[ 60:3000 ]( n1 >= L )
	P( n1>0 U n1 >= L)
endproperties
