//Type: Basic event; Original name: BUS_11; Assigned unique id: 0
module BE_0
  fc_0 : clock;
  rc_0 : clock;
  inform_0 : [0..2] init 0;
  brokenFlag_0 : [0..2] init 0;

  [] brokenFlag_0==0 @ fc_0 -> (inform_0'=1) & (brokenFlag_0'=1);
  [r_0??] brokenFlag_0==1 -> (brokenFlag_0'=2) & (rc_0'=uniform(6,12));
  [] brokenFlag_0==2 @ rc_0 -> (inform_0'=2) & (brokenFlag_0'=0) & (fc_0'=exponential(0.0000010));
  

  [f_0!!] inform_0==1 -> (inform_0'=0);
  [u_0!!] inform_0==2 -> (inform_0'=0);
endmodule

//Type: Basic event; Original name: BUS_12; Assigned unique id: 1
module BE_1
  fc_1 : clock;
  rc_1 : clock;
  inform_1 : [0..2] init 0;
  brokenFlag_1 : [0..2] init 0;

  [] brokenFlag_1==0 @ fc_1 -> (inform_1'=1) & (brokenFlag_1'=1);
  [r_1??] brokenFlag_1==1 -> (brokenFlag_1'=2) & (rc_1'=uniform(6,12));
  [] brokenFlag_1==2 @ rc_1 -> (inform_1'=2) & (brokenFlag_1'=0) & (fc_1'=exponential(0.0000010));
  

  [f_1!!] inform_1==1 -> (inform_1'=0);
  [u_1!!] inform_1==2 -> (inform_1'=0);
endmodule

//Type: AND gate; Original name: BSF_1; Assigned unique id: 2
module AND_2
  informf_2: bool init false;
  informu_2: bool init false;
  count_2: [0..2] init 0;

  [f_0??] count_2==0 -> (count_2'=1);
  [f_0??] count_2==1 -> (count_2'=2) & (informf_2'=true);
  [f_1??] count_2==0 -> (count_2'=1);
  [f_1??] count_2==1 -> (count_2'=2) & (informf_2'=true);

  [u_0??] count_2==1 -> (count_2'=0);
  [u_0??] count_2==2 -> (count_2'=1) & (informu_2'=true);
  [u_1??] count_2==1 -> (count_2'=0);
  [u_1??] count_2==2 -> (count_2'=1) & (informu_2'=true);

  [f_2!!] informf_2 & count_2==2 -> (informf_2'=false);
  [u_2!!] informu_2 & count_2<2 -> (informu_2'=false);
endmodule

//Type: Basic event; Original name: SW_1; Assigned unique id: 3
module BE_3
  fc_3 : clock;
  rc_3 : clock;
  inform_3 : [0..2] init 0;
  brokenFlag_3 : [0..2] init 0;

  [] brokenFlag_3==0 @ fc_3 -> (inform_3'=1) & (brokenFlag_3'=1);
  [r_3??] brokenFlag_3==1 -> (brokenFlag_3'=2) & (rc_3'=uniform(6,12));
  [] brokenFlag_3==2 @ rc_3 -> (inform_3'=2) & (brokenFlag_3'=0) & (fc_3'=exponential(0.000060));
  

  [f_3!!] inform_3==1 -> (inform_3'=0);
  [u_3!!] inform_3==2 -> (inform_3'=0);
endmodule

//Type: Basic event; Original name: HW_1; Assigned unique id: 4
module BE_4
  fc_4 : clock;
  rc_4 : clock;
  inform_4 : [0..2] init 0;
  brokenFlag_4 : [0..2] init 0;

  [] brokenFlag_4==0 @ fc_4 -> (inform_4'=1) & (brokenFlag_4'=1);
  [r_4??] brokenFlag_4==1 -> (brokenFlag_4'=2) & (rc_4'=uniform(6,12));
  [] brokenFlag_4==2 @ rc_4 -> (inform_4'=2) & (brokenFlag_4'=0) & (fc_4'=exponential(0.000050));
  

  [f_4!!] inform_4==1 -> (inform_4'=0);
  [u_4!!] inform_4==2 -> (inform_4'=0);
endmodule

//Type: OR gate; Original name: IF_1; Assigned unique id: 5
module OR_5
  informf_5: bool init false;
  informu_5: bool init false;
  count_5: [0..2] init 0;

  [f_3??] count_5==0 -> (count_5'=1) & (informf_5'=true);
  [f_3??] count_5==1 -> (count_5'=2);
  [f_4??] count_5==0 -> (count_5'=1) & (informf_5'=true);
  [f_4??] count_5==1 -> (count_5'=2);

  [u_3??] count_5==1 -> (count_5'=0) & (informu_5'=true);
  [u_3??] count_5==2 -> (count_5'=1);
  [u_4??] count_5==1 -> (count_5'=0) & (informu_5'=true);
  [u_4??] count_5==2 -> (count_5'=1);

  [f_5!!] informf_5 & count_5>0 -> (informf_5'=false);
  [u_5!!] informu_5 & count_5==0 -> (informu_5'=false);
endmodule

//Type: Basic event; Original name: A_11; Assigned unique id: 6
module BE_6
  fc_6 : clock;
  rc_6 : clock;
  inform_6 : [0..2] init 0;
  brokenFlag_6 : [0..2] init 0;

  [] brokenFlag_6==0 @ fc_6 -> (inform_6'=1) & (brokenFlag_6'=1);
  [r_6??] brokenFlag_6==1 -> (brokenFlag_6'=2) & (rc_6'=uniform(6,12));
  [] brokenFlag_6==2 @ rc_6 -> (inform_6'=2) & (brokenFlag_6'=0) & (fc_6'=exponential(0.00010));
  

  [f_6!!] inform_6==1 -> (inform_6'=0);
  [u_6!!] inform_6==2 -> (inform_6'=0);
endmodule

//Type: MUX with priority policy; Assigned name: MUX_for_A_1S; Assigned unique id: 10
module MUX_10
  rej_10[2]: bool init false;
  queue_10[2]: bool init false;
  available_10: bool init true;
  broken_10: bool init false;
  activate_10 : [0..2] init 0;

  [f_7??] -> (broken_10'=true) & (available_10'=true);
  [u_7??] -> (broken_10'=false);

//Comunication from multiplexers to spare gates. The relationship is many to many. We use the naming convention <action_name>_<id_from>_<id_to>
  [rq_10_8??] broken_10 | !available_10 -> (queue_10[0]'=true) & (rej_10[0]'=true);
  [rq_10_8??] !broken_10 & available_10 -> (queue_10[0]'=true);
  [asg_10_8!!] !broken_10 & available_10 & fsteq(queue_10,true) == 0 & activate_10==0 -> (available_10'=false) & (queue_10[0]'=false) & (activate_10' = 1);
  [rel_10_8??] -> (available_10'=true) & (activate_10' = 2);
  [rj_10_8!!] rej_10[0] -> (rej_10[0]'=false);
  [rq_10_9??] broken_10 | !available_10 -> (queue_10[1]'=true) & (rej_10[1]'=true);
  [rq_10_9??] !broken_10 & available_10 -> (queue_10[1]'=true);
  [asg_10_9!!] !broken_10 & available_10 & fsteq(queue_10,true) == 1 & activate_10==0 -> (available_10'=false) & (queue_10[1]'=false) & (activate_10' = 1);
  [rel_10_9??] -> (available_10'=true) & (activate_10' = 2);
  [rj_10_9!!] rej_10[1] -> (rej_10[1]'=false);

  [a_7!!] activate_10 == 1 -> (activate_10'=0);
  [d_7!!] activate_10 == 2 -> (activate_10'=0);

endmodule

//Type: Basic event; Original name: A_1S; Assigned unique id: 7
module BE_7
  fc_7 : clock;
  dfc_7 : clock;
  rc_7 : clock;
  inform_7 : [0..2] init 0;
  active_7 : bool init false;
  brokenFlag_7 : [0..2] init 0;

  [a_7??] !active_7 -> (active_7'=true) & (fc_7'=exponential(0.00010));
  [d_7??] active_7 -> (active_7'=false) & (dfc_7'=exponential(0.0));
  
  [] active_7 & brokenFlag_7==0 @ fc_7 -> (inform_7'=1) & (brokenFlag_7'=1);
  [] !active_7 & brokenFlag_7==0 @ dfc_7 -> (inform_7'=1) & (brokenFlag_7'=1);
  [r_7??] brokenFlag_7==1 -> (brokenFlag_7'=2) & (rc_7'=uniform(6,12));
  [] active_7 & brokenFlag_7==2 @ rc_7 -> (inform_7'=2) & (brokenFlag_7'=0) & (fc_7'=exponential(0.00010));
  [] !active_7 & brokenFlag_7==2 @ rc_7 -> (inform_7'=2) & (brokenFlag_7'=0) & (dfc_7'=exponential(0.0));
  

  [f_7!!] inform_7==1 -> (inform_7'=0);
  [u_7!!] inform_7==2 -> (inform_7'=0);
endmodule

//Type: spare gate; Original name: P_11; Assigned unique id: 8
module SPAREGATE_8
  state_8: [0..4] init 0; // on main, request, wait, on spare, broken
  inform_8: [0..2] init 0;
  release_8: [0..1] init 0;
  idx_8: [1..1] init 1;

  [f_6??] state_8==0 -> (state_8'=1) & (idx_8'=1); // main fails
  [u_6??] state_8==4 -> (inform_8'=2) & (state_8'=0); // main gets repaired
  [u_6??] state_8==3 -> (release_8'=idx_8) & (state_8'=0);


  [f_7??] state_8==3 & idx_8==1 -> (state_8'=1) & (idx_8'=1); // $Number 1 spare fails

  [rq_10_8!!] state_8==1 & idx_8==1 -> (state_8'=2); // request spare number 1

  [asg_10_8??] state_8==0 | state_8==1 | state_8==3 -> (release_8'=1); // we are assigned spare 1 but we dont want it
  [asg_10_8??] state_8==2 & idx_8==1 -> (state_8'=3); // we are assigned spare 1
  [asg_10_8??] state_8==4 -> (state_8'=3) & (idx_8'=1) & (inform_8'=2); // we 'get fixed' by a spare assignment
  
  [rj_10_8??] state_8==2 & idx_8==1 -> (state_8'=4) & (idx_8'=1) & (inform_8'=1);
  
  [rel_10_8!!] release_8==1 -> (release_8'= 0); // release spare 1

  [f_8!!] inform_8 == 1 -> (inform_8'=0);
  [u_8!!] inform_8 == 2 -> (inform_8'=0);
endmodule

//Type: Basic event; Original name: A_12; Assigned unique id: 11
module BE_11
  fc_11 : clock;
  rc_11 : clock;
  inform_11 : [0..2] init 0;
  brokenFlag_11 : [0..2] init 0;

  [] brokenFlag_11==0 @ fc_11 -> (inform_11'=1) & (brokenFlag_11'=1);
  [r_11??] brokenFlag_11==1 -> (brokenFlag_11'=2) & (rc_11'=uniform(6,12));
  [] brokenFlag_11==2 @ rc_11 -> (inform_11'=2) & (brokenFlag_11'=0) & (fc_11'=exponential(0.00010));
  

  [f_11!!] inform_11==1 -> (inform_11'=0);
  [u_11!!] inform_11==2 -> (inform_11'=0);
endmodule

//Type: spare gate; Original name: P_12; Assigned unique id: 9
module SPAREGATE_9
  state_9: [0..4] init 0; // on main, request, wait, on spare, broken
  inform_9: [0..2] init 0;
  release_9: [0..1] init 0;
  idx_9: [1..1] init 1;

  [f_11??] state_9==0 -> (state_9'=1) & (idx_9'=1); // main fails
  [u_11??] state_9==4 -> (inform_9'=2) & (state_9'=0); // main gets repaired
  [u_11??] state_9==3 -> (release_9'=idx_9) & (state_9'=0);


  [f_7??] state_9==3 & idx_9==1 -> (state_9'=1) & (idx_9'=1); // $Number 1 spare fails

  [rq_10_9!!] state_9==1 & idx_9==1 -> (state_9'=2); // request spare number 1

  [asg_10_9??] state_9==0 | state_9==1 | state_9==3 -> (release_9'=1); // we are assigned spare 1 but we dont want it
  [asg_10_9??] state_9==2 & idx_9==1 -> (state_9'=3); // we are assigned spare 1
  [asg_10_9??] state_9==4 -> (state_9'=3) & (idx_9'=1) & (inform_9'=2); // we 'get fixed' by a spare assignment
  
  [rj_10_9??] state_9==2 & idx_9==1 -> (state_9'=4) & (idx_9'=1) & (inform_9'=1);
  
  [rel_10_9!!] release_9==1 -> (release_9'= 0); // release spare 1

  [f_9!!] inform_9 == 1 -> (inform_9'=0);
  [u_9!!] inform_9 == 2 -> (inform_9'=0);
endmodule

//Type: AND gate; Original name: PSF_1; Assigned unique id: 12
module AND_12
  informf_12: bool init false;
  informu_12: bool init false;
  count_12: [0..2] init 0;

  [f_8??] count_12==0 -> (count_12'=1);
  [f_8??] count_12==1 -> (count_12'=2) & (informf_12'=true);
  [f_9??] count_12==0 -> (count_12'=1);
  [f_9??] count_12==1 -> (count_12'=2) & (informf_12'=true);

  [u_8??] count_12==1 -> (count_12'=0);
  [u_8??] count_12==2 -> (count_12'=1) & (informu_12'=true);
  [u_9??] count_12==1 -> (count_12'=0);
  [u_9??] count_12==2 -> (count_12'=1) & (informu_12'=true);

  [f_12!!] informf_12 & count_12==2 -> (informf_12'=false);
  [u_12!!] informu_12 & count_12<2 -> (informu_12'=false);
endmodule

//Type: Basic event; Original name: M_1_1; Assigned unique id: 13
module BE_13
  fc_13 : clock;
  rc_13 : clock;
  inform_13 : [0..2] init 0;
  brokenFlag_13 : [0..2] init 0;

  [] brokenFlag_13==0 @ fc_13 -> (inform_13'=1) & (brokenFlag_13'=1);
  [r_13??] brokenFlag_13==1 -> (brokenFlag_13'=2) & (rc_13'=uniform(6,12));
  [] brokenFlag_13==2 @ rc_13 -> (inform_13'=2) & (brokenFlag_13'=0) & (fc_13'=exponential(0.000060));
  

  [f_13!!] inform_13==1 -> (inform_13'=0);
  [u_13!!] inform_13==2 -> (inform_13'=0);
endmodule

//Type: Basic event; Original name: M_1_2; Assigned unique id: 14
module BE_14
  fc_14 : clock;
  rc_14 : clock;
  inform_14 : [0..2] init 0;
  brokenFlag_14 : [0..2] init 0;

  [] brokenFlag_14==0 @ fc_14 -> (inform_14'=1) & (brokenFlag_14'=1);
  [r_14??] brokenFlag_14==1 -> (brokenFlag_14'=2) & (rc_14'=uniform(6,12));
  [] brokenFlag_14==2 @ rc_14 -> (inform_14'=2) & (brokenFlag_14'=0) & (fc_14'=exponential(0.000060));
  

  [f_14!!] inform_14==1 -> (inform_14'=0);
  [u_14!!] inform_14==2 -> (inform_14'=0);
endmodule

//Type: Basic event; Original name: M_1_3; Assigned unique id: 15
module BE_15
  fc_15 : clock;
  rc_15 : clock;
  inform_15 : [0..2] init 0;
  brokenFlag_15 : [0..2] init 0;

  [] brokenFlag_15==0 @ fc_15 -> (inform_15'=1) & (brokenFlag_15'=1);
  [r_15??] brokenFlag_15==1 -> (brokenFlag_15'=2) & (rc_15'=uniform(6,12));
  [] brokenFlag_15==2 @ rc_15 -> (inform_15'=2) & (brokenFlag_15'=0) & (fc_15'=exponential(0.000060));
  

  [f_15!!] inform_15==1 -> (inform_15'=0);
  [u_15!!] inform_15==2 -> (inform_15'=0);
endmodule

//Type: Basic event; Original name: M_1_4; Assigned unique id: 16
module BE_16
  fc_16 : clock;
  rc_16 : clock;
  inform_16 : [0..2] init 0;
  brokenFlag_16 : [0..2] init 0;

  [] brokenFlag_16==0 @ fc_16 -> (inform_16'=1) & (brokenFlag_16'=1);
  [r_16??] brokenFlag_16==1 -> (brokenFlag_16'=2) & (rc_16'=uniform(6,12));
  [] brokenFlag_16==2 @ rc_16 -> (inform_16'=2) & (brokenFlag_16'=0) & (fc_16'=exponential(0.000060));
  

  [f_16!!] inform_16==1 -> (inform_16'=0);
  [u_16!!] inform_16==2 -> (inform_16'=0);
endmodule

//Type: Basic event; Original name: M_1_5; Assigned unique id: 17
module BE_17
  fc_17 : clock;
  rc_17 : clock;
  inform_17 : [0..2] init 0;
  brokenFlag_17 : [0..2] init 0;

  [] brokenFlag_17==0 @ fc_17 -> (inform_17'=1) & (brokenFlag_17'=1);
  [r_17??] brokenFlag_17==1 -> (brokenFlag_17'=2) & (rc_17'=uniform(6,12));
  [] brokenFlag_17==2 @ rc_17 -> (inform_17'=2) & (brokenFlag_17'=0) & (fc_17'=exponential(0.000060));
  

  [f_17!!] inform_17==1 -> (inform_17'=0);
  [u_17!!] inform_17==2 -> (inform_17'=0);
endmodule

//Type: Voting 3/5 gate; Original name: MSF_1; Assigned unique id: 18
module VOTING_18
  informf_18: bool init false;
  informu_18: bool init false;
  count_18: [0..5] init 0;

  [f_13??] count_18==0 -> (count_18'=1);
  [f_13??] count_18==1 -> (count_18'=2);
  [f_13??] count_18==2 -> (count_18'=3) & (informf_18'=true);
  [f_13??] count_18==3 -> (count_18'=4) & (informf_18'=true);
  [f_13??] count_18==4 -> (count_18'=5) & (informf_18'=true);
  [f_14??] count_18==0 -> (count_18'=1);
  [f_14??] count_18==1 -> (count_18'=2);
  [f_14??] count_18==2 -> (count_18'=3) & (informf_18'=true);
  [f_14??] count_18==3 -> (count_18'=4) & (informf_18'=true);
  [f_14??] count_18==4 -> (count_18'=5) & (informf_18'=true);
  [f_15??] count_18==0 -> (count_18'=1);
  [f_15??] count_18==1 -> (count_18'=2);
  [f_15??] count_18==2 -> (count_18'=3) & (informf_18'=true);
  [f_15??] count_18==3 -> (count_18'=4) & (informf_18'=true);
  [f_15??] count_18==4 -> (count_18'=5) & (informf_18'=true);
  [f_16??] count_18==0 -> (count_18'=1);
  [f_16??] count_18==1 -> (count_18'=2);
  [f_16??] count_18==2 -> (count_18'=3) & (informf_18'=true);
  [f_16??] count_18==3 -> (count_18'=4) & (informf_18'=true);
  [f_16??] count_18==4 -> (count_18'=5) & (informf_18'=true);
  [f_17??] count_18==0 -> (count_18'=1);
  [f_17??] count_18==1 -> (count_18'=2);
  [f_17??] count_18==2 -> (count_18'=3) & (informf_18'=true);
  [f_17??] count_18==3 -> (count_18'=4) & (informf_18'=true);
  [f_17??] count_18==4 -> (count_18'=5) & (informf_18'=true);

  [u_13??] count_18==1 -> (count_18'=0);
  [u_13??] count_18==2 -> (count_18'=1);
  [u_13??] count_18==3 -> (count_18'=2) & (informu_18'=true);
  [u_13??] count_18==4 -> (count_18'=3) & (informu_18'=true);
  [u_13??] count_18==5 -> (count_18'=4) & (informu_18'=true);
  [u_14??] count_18==1 -> (count_18'=0);
  [u_14??] count_18==2 -> (count_18'=1);
  [u_14??] count_18==3 -> (count_18'=2) & (informu_18'=true);
  [u_14??] count_18==4 -> (count_18'=3) & (informu_18'=true);
  [u_14??] count_18==5 -> (count_18'=4) & (informu_18'=true);
  [u_15??] count_18==1 -> (count_18'=0);
  [u_15??] count_18==2 -> (count_18'=1);
  [u_15??] count_18==3 -> (count_18'=2) & (informu_18'=true);
  [u_15??] count_18==4 -> (count_18'=3) & (informu_18'=true);
  [u_15??] count_18==5 -> (count_18'=4) & (informu_18'=true);
  [u_16??] count_18==1 -> (count_18'=0);
  [u_16??] count_18==2 -> (count_18'=1);
  [u_16??] count_18==3 -> (count_18'=2) & (informu_18'=true);
  [u_16??] count_18==4 -> (count_18'=3) & (informu_18'=true);
  [u_16??] count_18==5 -> (count_18'=4) & (informu_18'=true);
  [u_17??] count_18==1 -> (count_18'=0);
  [u_17??] count_18==2 -> (count_18'=1);
  [u_17??] count_18==3 -> (count_18'=2) & (informu_18'=true);
  [u_17??] count_18==4 -> (count_18'=3) & (informu_18'=true);
  [u_17??] count_18==5 -> (count_18'=4) & (informu_18'=true);

  [f_18!!] informf_18 & count_18>=3 -> (informf_18'=false);
  [u_18!!] informu_18 & count_18<3 -> (informu_18'=false);
endmodule

//Type: OR gate; Original name: System_1; Assigned unique id: 19
module OR_19
  informf_19: bool init false;
  informu_19: bool init false;
  count_19: [0..4] init 0;

  [f_2??] count_19==0 -> (count_19'=1) & (informf_19'=true);
  [f_2??] count_19==1 -> (count_19'=2);
  [f_2??] count_19==2 -> (count_19'=3);
  [f_2??] count_19==3 -> (count_19'=4);
  [f_5??] count_19==0 -> (count_19'=1) & (informf_19'=true);
  [f_5??] count_19==1 -> (count_19'=2);
  [f_5??] count_19==2 -> (count_19'=3);
  [f_5??] count_19==3 -> (count_19'=4);
  [f_12??] count_19==0 -> (count_19'=1) & (informf_19'=true);
  [f_12??] count_19==1 -> (count_19'=2);
  [f_12??] count_19==2 -> (count_19'=3);
  [f_12??] count_19==3 -> (count_19'=4);
  [f_18??] count_19==0 -> (count_19'=1) & (informf_19'=true);
  [f_18??] count_19==1 -> (count_19'=2);
  [f_18??] count_19==2 -> (count_19'=3);
  [f_18??] count_19==3 -> (count_19'=4);

  [u_2??] count_19==1 -> (count_19'=0) & (informu_19'=true);
  [u_2??] count_19==2 -> (count_19'=1);
  [u_2??] count_19==3 -> (count_19'=2);
  [u_2??] count_19==4 -> (count_19'=3);
  [u_5??] count_19==1 -> (count_19'=0) & (informu_19'=true);
  [u_5??] count_19==2 -> (count_19'=1);
  [u_5??] count_19==3 -> (count_19'=2);
  [u_5??] count_19==4 -> (count_19'=3);
  [u_12??] count_19==1 -> (count_19'=0) & (informu_19'=true);
  [u_12??] count_19==2 -> (count_19'=1);
  [u_12??] count_19==3 -> (count_19'=2);
  [u_12??] count_19==4 -> (count_19'=3);
  [u_18??] count_19==1 -> (count_19'=0) & (informu_19'=true);
  [u_18??] count_19==2 -> (count_19'=1);
  [u_18??] count_19==3 -> (count_19'=2);
  [u_18??] count_19==4 -> (count_19'=3);

  [f_19!!] informf_19 & count_19>0 -> (informf_19'=false);
  [u_19!!] informu_19 & count_19==0 -> (informu_19'=false);
endmodule

//Type: Repair box with priority policy; Original name: RS1; Assigned unique id: 20
module RBOX_20
  brokenFlag_20[12]: bool init false;
  busy_20: bool init false;

  [f_4??] -> (brokenFlag_20[0]'=true);
  [f_3??] -> (brokenFlag_20[1]'=true);
  [f_0??] -> (brokenFlag_20[2]'=true);
  [f_1??] -> (brokenFlag_20[3]'=true);
  [f_11??] -> (brokenFlag_20[4]'=true);
  [f_6??] -> (brokenFlag_20[5]'=true);
  [f_7??] -> (brokenFlag_20[6]'=true);
  [f_13??] -> (brokenFlag_20[7]'=true);
  [f_14??] -> (brokenFlag_20[8]'=true);
  [f_15??] -> (brokenFlag_20[9]'=true);
  [f_16??] -> (brokenFlag_20[10]'=true);
  [f_17??] -> (brokenFlag_20[11]'=true);

  [r_4!!] !busy_20 & fsteq(brokenFlag_20,true) == 0 -> (busy_20'=true);
  [r_3!!] !busy_20 & fsteq(brokenFlag_20,true) == 1 -> (busy_20'=true);
  [r_0!!] !busy_20 & fsteq(brokenFlag_20,true) == 2 -> (busy_20'=true);
  [r_1!!] !busy_20 & fsteq(brokenFlag_20,true) == 3 -> (busy_20'=true);
  [r_11!!] !busy_20 & fsteq(brokenFlag_20,true) == 4 -> (busy_20'=true);
  [r_6!!] !busy_20 & fsteq(brokenFlag_20,true) == 5 -> (busy_20'=true);
  [r_7!!] !busy_20 & fsteq(brokenFlag_20,true) == 6 -> (busy_20'=true);
  [r_13!!] !busy_20 & fsteq(brokenFlag_20,true) == 7 -> (busy_20'=true);
  [r_14!!] !busy_20 & fsteq(brokenFlag_20,true) == 8 -> (busy_20'=true);
  [r_15!!] !busy_20 & fsteq(brokenFlag_20,true) == 9 -> (busy_20'=true);
  [r_16!!] !busy_20 & fsteq(brokenFlag_20,true) == 10 -> (busy_20'=true);
  [r_17!!] !busy_20 & fsteq(brokenFlag_20,true) == 11 -> (busy_20'=true);

  [u_4??] -> (brokenFlag_20[0]'=false) & (busy_20'=false);
  [u_3??] -> (brokenFlag_20[1]'=false) & (busy_20'=false);
  [u_0??] -> (brokenFlag_20[2]'=false) & (busy_20'=false);
  [u_1??] -> (brokenFlag_20[3]'=false) & (busy_20'=false);
  [u_11??] -> (brokenFlag_20[4]'=false) & (busy_20'=false);
  [u_6??] -> (brokenFlag_20[5]'=false) & (busy_20'=false);
  [u_7??] -> (brokenFlag_20[6]'=false) & (busy_20'=false);
  [u_13??] -> (brokenFlag_20[7]'=false) & (busy_20'=false);
  [u_14??] -> (brokenFlag_20[8]'=false) & (busy_20'=false);
  [u_15??] -> (brokenFlag_20[9]'=false) & (busy_20'=false);
  [u_16??] -> (brokenFlag_20[10]'=false) & (busy_20'=false);
  [u_17??] -> (brokenFlag_20[11]'=false) & (busy_20'=false);

endmodule


const float t_limit = 1.0; 
const float epsilon = 0.01;

module ReliabilityTimer
  ReliabilityTimeOut: [0..2] init 0;
  clkTO: clock;
  [TOinit!!] ReliabilityTimeOut == 0 -> (ReliabilityTimeOut'=1) & (clkTO'=uniform(t_limit - epsilon,t_limit + epsilon));
  [] ReliabilityTimeOut==1 @ clkTO -> (ReliabilityTimeOut'=2);
endmodule

properties
  P( ReliabilityTimeOut<2  U count_19>0  ) //Top event
endproperties


// FIG command examples:
// fig <filePath> --flat --stop-conf .8 .4 --timeout 2m
// fig <filePath> --dft --stop-conf .8 .4 --timeout 2m -e restart -t es --acomp 'max(BE_0+BE_1,max(BE_3,BE_4),BE_6+BE_7+BE_11+BE_7,min(3,BE_13+BE_14+BE_15+BE_16+BE_17));0;4'
// fig <filePath> --dft --stop-conf .8 .4 --timeout 2m -e restart -t hyb --acomp 'max(BE_0+BE_1,max(BE_3,BE_4),BE_6+BE_7+BE_11+BE_7,min(3,BE_13+BE_14+BE_15+BE_16+BE_17));0;4'
// fig <filePath> --dft --stop-conf .8 .4 --timeout 2m -e fixedeffort -t es --acomp 'max(BE_0+BE_1,max(BE_3,BE_4),BE_6+BE_7+BE_11+BE_7,min(3,BE_13+BE_14+BE_15+BE_16+BE_17));0;4'
// fig <filePath> --dft --stop-conf .8 .4 --timeout 2m -e fixedeffort -t hyb --acomp 'max(BE_0+BE_1,max(BE_3,BE_4),BE_6+BE_7+BE_11+BE_7,min(3,BE_13+BE_14+BE_15+BE_16+BE_17));0;4'
// Compositional importance function for FIG tool:
// max(BE_0+BE_1,max(BE_3,BE_4),BE_6+BE_7+BE_11+BE_7,min(3,BE_13+BE_14+BE_15+BE_16+BE_17));0;4