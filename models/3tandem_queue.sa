/*
 * Three queue tandem network for the FIG tool
 * Budde, Monti, D'Argenio | 2016
 *
 * {-
 * Stochastic three-queue tandem network concept:
 *            q1               q2               q3
 * ----> [..@@@@] ------> [....@@] ------> [....@@] ----->
 * 'arr'          'pass1'          'pass2'          'exit'
 *
 * 'arr'   tells a packet arrives at q1         (clock 'clkA' )
 * 'pass1' tells a packet passes from q1 to q2  (clock 'clkP1')
 * 'pass2' tells a packet passes from q2 to q3  (clock 'clkP2')
 * 'exit'  tells a packet exits q3              (clock 'clkP3')
 * 
 * Packet arrivals at the first queue are Poisson with rate 'lambda' = 1,2
 * Queues service times are Erlang (i.e. Gamma for integral shape parameter)
 * with shape parameter 'alpha' = 2,3 and various rate parameters 'mu1',
 * 'mu2' and 'mu3'.
 *
 * Property type: RATE ("steady-state probability of rare event")
 * Rare events: reach threshold occupancy 'L' in q3
 * Reference events: any system transition
 * Initial state: all queues empty
 * Initial clocks: clkA
 * -}
 */


// -- The following values were extracted from José Villén-Altamirano,
// -- "RESTART simulation of networks of queues with Erlang service times",
// -- Winter Simulation Conference, 2009, pp. 1146-1154.
// -- This model corresponds to the system described in Section 4.1

const int lambda = 2;	// Arrival rates (Queue1): 1, 2
const int alpha = 2;	// Service time shape parameters (all queues): 2, 3
const int mu1 = 3;		// Service time rate  parameters (Queue1): 3, 5
const int mu2 = 2;		// Service time rate  parameters (Queue2): 2, 4
const int mu3 = 3;		// Service time rate  parameters (Queue3): 3
const int L = 18;		// Threshold occupancy (Queue3): 13, 16, 18, 20, 21, 24
const int c = L;		// Queues capacity

// -- Combinations tested in the aforementioned article, in the format
// --     lambda, alpha, mu1, mu2, L :
// --  a)   2   ,   2  ,  3 ,  2 , 18
// --  b)   2   ,   3  ,  3 ,  2 , 13
// --  c)   1   ,   2  ,  3 ,  2 , 20
// --  d)   1   ,   3  ,  3 ,  2 , 16
// --  e)   1   ,   2  ,  5 ,  4 , 24
// --  f)   1   ,   3  ,  5 ,  4 , 21

module Queue1

	q1: [0..c];
	clkA:  clock;  // -- Queue1 'A'rrivals   ~ exp(lambda)
	clkP1: clock;  // -- Queue1 'P'rocessing ~ erlang(alpha,mu1)

	// -- Packet arrival
	[] 0 == q1 @ clkA -> (q1'= 1) &
	                     (clkA' = exponential(1)) &
	                     (clkP1'= erlang(alpha, mu1));
    [] 0 < q1 & q1 < c @ clkA -> (q1'= q1+1) &
	                             (clkA'= exponential(1));
    [] q1 == c         @ clkA -> (clkA'= exponential(1));
// --    [] 0 < q1  @ clkA -> (q1'= min(q1+1, c)) &
// --	                      (clkA'= exponential(1));

	// -- Packet passage to Queue2
	[pass1!] 1 == q1 @ clkP1 -> (q1'= 0);
	[pass1!] 1 < q1  @ clkP1 -> (q1'= q1-1) & (clkP1'= erlang(alpha, mu1));

endmodule


module Queue2

	q2: [0..c];
	clkP2: clock;  // -- Queue2 'P'rocessing ~ erlang(alpha,mu2)

	// -- Packet passage from Queue1
	[pass1?] 0 == q2 -> (q2'= 1) & (clkP2'= erlang(alpha, mu2));
	[pass1?] 0 < q2 & q2 < c  -> (q2'= q2+1);
	[pass1?] q2 == c          -> ;
// --	[pass2?] 0 < q3  -> (q3'= min(q3+1, c));

	// -- Packet passage to Queue3
	[pass2!] 1 == q2 @ clkP2 -> (q2'= 0);
	[pass2!] 1 < q2  @ clkP2 -> (q2'= q2-1) & (clkP2'= erlang(alpha, mu2));

endmodule


module Queue3

	q3: [0..c];
	clkP3: clock;  // -- Queue3 'P'rocessing ~ erlang(alpha,mu3)

	// -- Packet passage from Queue2
	[pass2?] 0 == q3 -> (q3'= 1) & (clkP3'= erlang(alpha, mu3));
	[pass2?] 0 < q3 & q3 < c  -> (q3'= q3+1);
	[pass2?] q3 == c          -> ;
// --	[pass2?] 0 < q3  -> (q3'= min(q3+1, c));

	// -- Packet exit
	[] 1 == q3 @ clkP3 -> (q3'= 0);
	[] 1 < q3  @ clkP3 -> (q3'= q3-1) & (clkP3'= erlang(alpha, mu3));

endmodule

