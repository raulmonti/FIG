/*
 * Three queue tandem network for the FIG tool
 * Budde, Monti, D'Argenio | 2016
 *
 * {-
 * Stochastic three-queue tandem network concept:
 *            q1               q2               q3
 * ----> [..@@@@] ------> [....@@] ------> [....@@] ----->
 * 'arr'          'pass1'          'pass2'          'exit'
 *
 * 'arr'   tells a packet arrives at q1         (clock 'clkA' )
 * 'pass1' tells a packet passes from q1 to q2  (clock 'clkP1')
 * 'pass2' tells a packet passes from q2 to q3  (clock 'clkP2')
 * 'exit'  tells a packet exits q3              (clock 'clkP3')
 * 
 * Packet arrivals at the first queue are Poisson with rate = 1.
 * Queues service times are Erlang (i.e. Gamma for integral shape parameter)
 * with shape parameter 'alpha' = 2,3 and various rate parameters 'mu1',
 * 'mu2' and 'mu3'.
 *
 * Property type: RATE ("steady-state probability of rare event")
 * Rare events: reach threshold occupancy 'L' in q3
 * Reference events: any system transition
 * Initial state: all queues empty
 * Initial clocks: clkA
 * -}
 */


// -- The following values were extracted from José Villén-Altamirano,
// -- "RESTART simulation of networks of queues with Erlang service times",
// -- Winter Simulation Conference, 2009, pp. 1146-1154.
// -- This model corresponds to the system described in Section 4.1

const int alpha = 2;	// Service time shape parameter (all queues): 2, 3
const int mu1 = 3;		// Service time rate  parameter (Queue1): 1.5, 3, 5
const int mu2 = 2;		// Service time rate  parameter (Queue2): 2, 4
const int mu3 = 3;		// Service time rate  parameter (Queue3): 3
const int L = 20;		// Threshold occupancy (Queue3): 13, 16, 18, 20, 21, 24
const int c = L;		// Queues capacity

// -- Combinations tested in the aforementioned article, in the format
// --     alpha, mu1, mu2, L :
// --  a)   2  , 1.5,  2 , 18
// --  b)   3  , 1.5,  2 , 13
// --  c)   2  ,  3 ,  2 , 20
// --  d)   3  ,  3 ,  2 , 16
// --  e)   2  ,  5 ,  4 , 24
// --  f)   3  ,  5 ,  4 , 21

module Arrivals
	clk0: clock;  // -- External arrivals ~ Exponential(1)
	[P0!] @ clk0 -> (clk0'= exponential(1));
endmodule

module Queue1
	q1: [0..c];
	clk1: clock;  // -- Queue1 'P'rocessing ~ Erlang(alpha,mu1)
	// -- Packet arrival
	[P0?] q1 == 0          -> (q1'= q1+1) & (clk1'= erlang(alpha, mu1));
	[P0?] q1  > 0 & q1 < c -> (q1'= q1+1);
	[P0?] q1 == c          -> ;
	// -- Packet processing
	[P1!] q1 == 1 @ clk1 -> (q1'= q1-1);
	[P1!] q1  > 1 @ clk1 -> (q1'= q1-1) & (clk1'= erlang(alpha, mu1));
endmodule

module Queue2
	q2: [0..c];
	clk2: clock;  // -- Queue2 'P'rocessing ~ Erlang(alpha,mu2)
	// -- Packet arrival
	[P1?] q2 == 0          -> (q2'= q2+1) & (clk2'= erlang(alpha, mu2));
	[P1?] q2  > 0 & q2 < c -> (q2'= q2+1);
	[P1?] q2 == c          -> ;
	// -- Packet processing
	[P2!] q2 == 1 @ clk2 -> (q2'= q2-1);
	[P2!] q2  > 1 @ clk2 -> (q2'= q2-1) & (clk2'= erlang(alpha, mu2));
endmodule

module Queue3
	q3: [0..c];
	clk3: clock;  // -- Queue3 'P'rocessing ~ Erlang(alpha,mu3)
	// -- Packet arrival
	[P2?] q3 == 0          -> (q3'= q3+1) & (clk3'= erlang(alpha, mu3));
	[P2?] q3  > 0 & q3 < c -> (q3'= q3+1);
	[P2?] q3 == c          -> ;
	// -- Packet processing
	[P3!] q3 == 1 @ clk3 -> (q3'= q3-1);
	[P3!] q3  > 1 @ clk3 -> (q3'= q3-1) & (clk3'= erlang(alpha, mu3));
endmodule

