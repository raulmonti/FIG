/*
 * Three queue tandem network for the FIG tool
 * Budde | 2019
 *
 * {-
 * Non-Jackson three-tandem queue network:
 * 
 *                    q1              q2              q3
 * ------------> [..@@@@] -----> [....@@] -----> [....@@] ----->
 *  p:l1,1-p:l2            a,b1            a,b2            a,b3
 *
 * All queues (q1,q2,q3) have assumed infinite capacity
 * New packets arrive at q1 following an hyper-exponential-2 distribution:
 *  - with probability   'p' they arrive at rate l1
 *  - with probability 1-'p' they arrive at rate l2
 * Packets in q1 are served following an Erlang(a,b1) and sent to q2
 * Packets in q2 are served following an Erlang(a,b2) and sent to q3
 * Packets in q3 are served following an Erlang(a,b3) and leave
 *
 * Rare events: q3 reaching a predefined limiting capacity 'L'
 * Stopping events (for transient analysis): q3 becoming empty
 * Initial state: q1=q2=0, q3=1
 * 
 * NOTE: for the event to be rare and interesting
 *       it is important that each queue is a bottleneck of the next,
 *       i.e. b1 < b2 < b3 ("earlier queues serve packets slowlier")
 * -}
 */

// Values taken from "RESTART vs. Splitting: A comparative study,"
// José Villén-Altamirano, Performance Evaluation 121-122 (2018) 38-47
                        
const int L = 30;          // Queue limiting capacity
const int c = L+99;        // Queues real capacity (mimic infinite size)
const float  p = 0.5;      // probability of arrival with rate l1
const float l1 = 7.0/1.0;  // rate(--> q1           ) first  possibility 
const float l2 = 7.0/6.0;  // rate(--> q1           ) second possibility 
const int alpha =  3;      // Shape parameter of the Erlang service times
const int beta1 =  9;      // rate(    q1 --> q2           ) of Erlang-alpha
const int beta2 = 12;      // rate(           q2 --> q3    ) of Erlang-alpha
const int beta3 = 18;      // rate(                  q3 -->) of Erlang-alpha

// Importance function used in the aforementioned article: 0.13*q1 + 0.5*q2 + q3
// Importance function used for fig: 13*q1 + 50*q2 + 100*q3
// Thresholds used in the article: as given below for fig, where thresholds values
//                                 where scaled by 100 and splittings are equal
// Thresholds used for fig: "150:2,250:3,300:2,350:3,400:2,450:3,500:3,550:3,600:3,650:3,700:3,750:3,800:3,850:3,900:3,950:3,1000:3,1050:3,1100:3,1150:3,1200:3,1250:3,1300:3,1350:3,1400:4,1450:3,1500:3,1550:4,1600:5"


module Arrivals
        clk0: clock;  // External arrivals ~ HyperExponential(p,l1,l2)
        [P0!] @ clk0 -> (clk0'= hyperexponential2(p,l1,l2));
endmodule

module Queue1
        q1: [0..c];
        clk1: clock;  // Queue1 processing ~ Exponential(b1)
        // Packet arrival
        [P0?] q1 == 0          -> (q1'= q1+1) & (clk1'= erlang(alpha,beta1));
        [P0?] q1  > 0 & q1 < c -> (q1'= q1+1);
        [P0?] q1 == c          -> ;
        // Packet processing
        [P1!] q1 == 1 @ clk1 -> (q1'= q1-1);
        [P1!] q1  > 1 @ clk1 -> (q1'= q1-1) & (clk1'= erlang(alpha,beta1));
endmodule

module Queue2
        q2: [0..c];
        clk2: clock;  // Queue2 processing ~ Exponential(b2)
        // Packet arrival
        [P1?] q2 == 0          -> (q2'= q2+1) & (clk2'= erlang(alpha,beta2));
        [P1?] q2  > 0 & q2 < c -> (q2'= q2+1);
        [P1?] q2 == c          -> ;
        // Packet processing
        [P2!] q2 == 1 @ clk2 -> (q2'= q2-1);
        [P2!] q2  > 1 @ clk2 -> (q2'= q2-1) & (clk2'= erlang(alpha,beta2));
endmodule

module Queue3
        q3: [0..c];
        clk3: clock;  // Queue3 processing ~ Exponential(b3)
        // Packet arrival
        [P2?] q3 == 0          -> (q3'= q3+1) & (clk3'= erlang(alpha,beta3));
        [P2?] q3  > 0 & q3 < c -> (q3'= q3+1);
        [P2?] q3 == c          -> ;
        // Packet processing
        [P3!] q3 == 1 @ clk3 -> (q3'= q3-1);
        [P3!] q3  > 1 @ clk3 -> (q3'= q3-1) & (clk3'= erlang(alpha,beta3));
endmodule


properties
	S[ 60:30000 ]( q3 >= L )  // "rate with time-bound"
//	S( q3 >= L )  // "rate"
//	S( (q1 >= c/2 & q2 >= L) | q3 >= L )  // "rate"
endproperties
