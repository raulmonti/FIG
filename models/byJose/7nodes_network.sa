/*
 * Seven-nodes queueing network for the FIG tool
 * Budde | 2019
 *
 * {-
 * Jackson seven-nodes network:
 * 
 *     __________TO____________ ____
 *    |   n1 n2 n3 n4 n5 n6 n7 | out|
 *    |n1 .1 .1 .1 .1 .2 .2  0 | .2 |  Probabilities
 *  F |n2 .1 .1 .1 .1 .2 .2  0 | .2 |  transition-matrix
 *  R |n3 .1 .1 .1 .1 .2 .2  0 | .2 |  of the seven nodes
 *  O |n4 .1 .1 .1 .1 .2 .2  0 | .2 |
 *  M |n5 .1 .1 .1 .1  0 .1 .3 | .2 |
 *    |n6 .1 .1 .1 .1 .1  0 .3 | .2 |
 *    |n7 .1 .1 .1 .1 .1 .1 .2 | .2 |
 *    +------------------------+----+
 *
 * All nodes {1,2,...,7} have assumed infinite capacity
 * New packets arrive and can leave from all nodes ("in parallel"):
 *  - external arrivals follow an exponential distribution with rate 1
 *  - a packet served in node i (at rate mu_i) makes a probabilistic choice:
 *    --> with probability 0.2 it leaves the system
 *    --> with the probabilities of the transition-matrix it goes to another node
 * Overall arrival rate at nodes: n1=n2=n3=n4:l_a ; n5=n6:l_b ; n7:l_c
 * Service rates of the nodes: n1=n2=n3=n4:mu_a < n5=n6:mu_b < n7:mu_c
 * Loads of the nodes: n1=n2=n3=n4:rho_a > n5=n6:rho_b > n7:rho_c
 * The 'load' of node i is: (1+in_other_nodes)/mu_i == l_x/mu_x
 *
 * Rare events: target node n7 reaching a predefined limiting capacity 'L'
 * Stopping events (for transient analysis): n7 becoming empty
 * Initial state: ni=0 for i=1,2,...,6; n7=1
 * 
 * NOTE: for the event to be rare and interesting
 *       it is important that lower-number nodes have heavier loads,
 *       i.e. rho_a > rho_b > rho_c ("earlier nodes serve packets slowlier")
 * -}
 */


// Values taken from "RESTART vs. Splitting: A comparative study,"
// Jose Villen-Altamirano, Performance Evaluation 121-122 (2018) 38-47

const int L = 8;//30;   // Queue limiting capacity
const int C = 2*L;  // Queues real capacity (mimic infinite size)
const float l_a = 4.5;
const float l_b = 5.73;
const float l_c = 5.55;
const int mu_a =  9;
const int mu_b = 14;
const int mu_c = 1; //17;
const float l1 = l_a;    // overall arrival rate at node n1
const float l2 = l_a;    // overall arrival rate at node n2
const float l3 = l_a;    // overall arrival rate at node n3
const float l4 = l_a;    // overall arrival rate at node n4
const float l5 = l_b;    // overall arrival rate at node n5
const float l6 = l_b;    // overall arrival rate at node n6
const float l7 = l_c;    // overall arrival rate at node n7
const float mu1 = mu_a;  //         service rate at node n1
const float mu2 = mu_a;  //         service rate at node n2
const float mu3 = mu_a;  //         service rate at node n3
const float mu4 = mu_a;  //         service rate at node n4
const float mu5 = mu_b;  //         service rate at node n5
const float mu6 = mu_b;  //         service rate at node n6
const float mu7 = mu_c;  //         service rate at node n7

// Importance function used in the aforementioned article:
//   0.23*(n1+n2+n3+n4) + 0.45*(n5+n6) + n7
// Importance function used for fig:
//   23*(n1+n2+n3+n4) + 45*(n5+n6) + 100*n7
// Thresholds used in the article: all importance values from 2-32,
//                                 with splitting == 3 for all except
//                                 2,3,32 which have splitting == 2
//                                 and 19 which has splitting == 4
// Thresholds used for fig: "200:2,300:2,400:3,500:3,600:3,700:3,800:3,900:3,1000:3,1100:3,1200:3,1300:3,1400:3,1500:3,1600:3,1700:3,1800:3,1900:4,2000:3,2100:3,2200:3,2300:3,2400:3,2500:3,2600:3,2700:3,2800:3,2900:3,3000:3,3100:3,3200:2"

// Transition matrix probabilities:
// column 1:
const float p1_1 = 0.1;
const float p2_1 = 0.1;
const float p3_1 = 0.1;
const float p4_1 = 0.1;
const float p5_1 = 0.1;
const float p6_1 = 0.1;
const float p7_1 = 0.1;
// column 2:
const float p1_2 = 0.1;
const float p2_2 = 0.1;
const float p3_2 = 0.1;
const float p4_2 = 0.1;
const float p5_2 = 0.1;
const float p6_2 = 0.1;
const float p7_2 = 0.1;
// column 3:
const float p1_3 = 0.1;
const float p2_3 = 0.1;
const float p3_3 = 0.1;
const float p4_3 = 0.1;
const float p5_3 = 0.1;
const float p6_3 = 0.1;
const float p7_3 = 0.1;
// column 4:
const float p1_4 = 0.1;
const float p2_4 = 0.1;
const float p3_4 = 0.1;
const float p4_4 = 0.1;
const float p5_4 = 0.1;
const float p6_4 = 0.1;
const float p7_4 = 0.1;
// column 5:
const float p1_5 = 0.2;
const float p2_5 = 0.2;
const float p3_5 = 0.2;
const float p4_5 = 0.2;
const float p5_5 = 0.0;
const float p6_5 = 0.1;
const float p7_5 = 0.1;
// column 6:
const float p1_6 = 0.2;
const float p2_6 = 0.2;
const float p3_6 = 0.2;
const float p4_6 = 0.2;
const float p5_6 = 0.1;
const float p6_6 = 0.0;
const float p7_6 = 0.1;
// column 7:
const float p1_7 = 0.0;
const float p2_7 = 0.0;
const float p3_7 = 0.0;
const float p4_7 = 0.0;
const float p5_7 = 0.3;
const float p6_7 = 0.3;
const float p7_7 = 0.2;
// column out:
const float p1_0 = 0.2;
const float p2_0 = 0.2;
const float p3_0 = 0.2;
const float p4_0 = 0.2;
const float p5_0 = 0.2;
const float p6_0 = 0.2;
const float p7_0 = 0.2;


module Node1
	n1:    [0..C];
	dest1: [0..7];  // 0=out   i=Nodei for i>0
	todo1: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr1: clock;  // extern arrival ~ exponential(1.0)
	c_ser1: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr1 -> (todo1'=1) & (c_arr1'= exponential(1.0));
//	[n1_n1?]    -> (todo1'=1);  // self-loop
	[n2_n1?]    -> (todo1'=1);
	[n3_n1?]    -> (todo1'=1);
	[n4_n1?]    -> (todo1'=1);
	[n5_n1?]    -> (todo1'=1);
	[n6_n1?]    -> (todo1'=1);
	[n7_n1?]    -> (todo1'=1);
	[arr1!!] todo1==1 & n1 == 0     -> (todo1'=2)
	                                 & (n1'= n1+1)
	                                 & (c_ser1'= exponential(mu1));
	[arr1!!] todo1==1 & n1>0 & n1<C -> (todo1'=0)
	                                 & (n1'= n1+1);
	[arr1!!] todo1==1 & n1 == C     -> (todo1'=0);
	// Choose next packet dest1ination
	[choose1!!] todo1==2 -> p1_0 : (dest1'=0) & (todo1'=0)
	                      + p1_1 : (dest1'=1) & (todo1'=0)
	                      + p1_2 : (dest1'=2) & (todo1'=0)
	                      + p1_3 : (dest1'=3) & (todo1'=0)
	                      + p1_4 : (dest1'=4) & (todo1'=0)
	                      + p1_5 : (dest1'=5) & (todo1'=0)
	                      + p1_6 : (dest1'=6) & (todo1'=0)
	                      + p1_7 : (dest1'=7) & (todo1'=0);
	// Packet service
	[n1_  !] n1>0 & dest1==0 @ c_ser1 -> (todo1'=3);
	[n1_n1!] n1>0 & dest1==1 @ c_ser1 -> (todo1'=2)  // self-loop
	                                   & (c_ser1'= exponential(mu1)); 
	[n1_n2!] n1>0 & dest1==2 @ c_ser1 -> (todo1'=3);
	[n1_n3!] n1>0 & dest1==3 @ c_ser1 -> (todo1'=3);
	[n1_n4!] n1>0 & dest1==4 @ c_ser1 -> (todo1'=3);
	[n1_n5!] n1>0 & dest1==5 @ c_ser1 -> (todo1'=3);
	[n1_n6!] n1>0 & dest1==6 @ c_ser1 -> (todo1'=3);
	[n1_n7!] n1>0 & dest1==7 @ c_ser1 -> (todo1'=3);
	[dep1!!] todo1==3 & n1 == 1 -> (n1'= 0)
	                             & (todo1'=0);
	[dep1!!] todo1==3 & n1  > 1 -> (n1'= n1-1)
	                             & (todo1'=2)
	                             & (c_ser1'= exponential(mu1));
endmodule


module Node2
	n2:    [0..C];
	dest2: [0..7];  // 0=out   i=Nodei for i>0
	todo2: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr2: clock;  // extern arrival ~ exponential(1.0)
	c_ser2: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr2 -> (todo2'=1) & (c_arr2'= exponential(1.0));
	[n1_n2?]    -> (todo2'=1);
//	[n2_n2?]    -> (todo2'=1);  // self-loop
	[n3_n2?]    -> (todo2'=1);
	[n4_n2?]    -> (todo2'=1);
	[n5_n2?]    -> (todo2'=1);
	[n6_n2?]    -> (todo2'=1);
	[n7_n2?]    -> (todo2'=1);
	[arr2!!] todo2==1 & n2 == 0     -> (todo2'=2)
	                                 & (n2'= n2+1)
	                                 & (c_ser2'= exponential(mu2));
	[arr2!!] todo2==1 & n2>0 & n2<C -> (todo2'=0)
	                                 & (n2'= n2+1);
	[arr2!!] todo2==1 & n2 == C     -> (todo2'=0);
	// Choose next packet dest2ination
	[choose2!!] todo2==2 -> p2_0 : (dest2'=0) & (todo2'=0)
	                      + p2_1 : (dest2'=1) & (todo2'=0)
	                      + p2_2 : (dest2'=2) & (todo2'=0)
	                      + p2_3 : (dest2'=3) & (todo2'=0)
	                      + p2_4 : (dest2'=4) & (todo2'=0)
	                      + p2_5 : (dest2'=5) & (todo2'=0)
	                      + p2_6 : (dest2'=6) & (todo2'=0)
	                      + p2_7 : (dest2'=7) & (todo2'=0);
	// Packet service
	[n2_  !] n2>0 & dest2==0 @ c_ser2 -> (todo2'=3);
	[n2_n1!] n2>0 & dest2==1 @ c_ser2 -> (todo2'=3);
	[n2_n2!] n2>0 & dest2==2 @ c_ser2 -> (todo2'=2)  // self-loop
	                                   & (c_ser2'= exponential(mu2)); 
	[n2_n3!] n2>0 & dest2==3 @ c_ser2 -> (todo2'=3);
	[n2_n4!] n2>0 & dest2==4 @ c_ser2 -> (todo2'=3);
	[n2_n5!] n2>0 & dest2==5 @ c_ser2 -> (todo2'=3);
	[n2_n6!] n2>0 & dest2==6 @ c_ser2 -> (todo2'=3);
	[n2_n7!] n2>0 & dest2==7 @ c_ser2 -> (todo2'=3);
	[dep2!!] todo2==3 & n2 == 1 -> (n2'= 0)
	                             & (todo2'=0);
	[dep2!!] todo2==3 & n2  > 1 -> (n2'= n2-1)
	                             & (todo2'=2)
	                             & (c_ser2'= exponential(mu2));
endmodule


module Node3
	n3:    [0..C];
	dest3: [0..7];  // 0=out   i=Nodei for i>0
	todo3: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr3: clock;  // extern arrival ~ exponential(1.0)
	c_ser3: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr3 -> (todo3'=1) & (c_arr3'= exponential(1.0));
	[n1_n3?]    -> (todo3'=1);
	[n2_n3?]    -> (todo3'=1);
//	[n3_n3?]    -> (todo3'=1);  // self-loop
	[n4_n3?]    -> (todo3'=1);
	[n5_n3?]    -> (todo3'=1);
	[n6_n3?]    -> (todo3'=1);
	[n7_n3?]    -> (todo3'=1);
	[arr3!!] todo3==1 & n3 == 0     -> (todo3'=2)
	                                 & (n3'= n3+1)
	                                 & (c_ser3'= exponential(mu3));
	[arr3!!] todo3==1 & n3>0 & n3<C -> (todo3'=0)
	                                 & (n3'= n3+1);
	[arr3!!] todo3==1 & n3 == C     -> (todo3'=0);
	// Choose next packet dest3ination
	[choose3!!] todo3==2 -> p3_0 : (dest3'=0) & (todo3'=0)
	                      + p3_1 : (dest3'=1) & (todo3'=0)
	                      + p3_2 : (dest3'=2) & (todo3'=0)
	                      + p3_3 : (dest3'=3) & (todo3'=0)
	                      + p3_4 : (dest3'=4) & (todo3'=0)
	                      + p3_5 : (dest3'=5) & (todo3'=0)
	                      + p3_6 : (dest3'=6) & (todo3'=0)
	                      + p3_7 : (dest3'=7) & (todo3'=0);
	// Packet service
	[n3_  !] n3>0 & dest3==0 @ c_ser3 -> (todo3'=3);
	[n3_n1!] n3>0 & dest3==1 @ c_ser3 -> (todo3'=3);
	[n3_n2!] n3>0 & dest3==2 @ c_ser3 -> (todo3'=3);
	[n3_n3!] n3>0 & dest3==3 @ c_ser3 -> (todo3'=2)  // self-loop
	                                   & (c_ser3'= exponential(mu3)); 
	[n3_n4!] n3>0 & dest3==4 @ c_ser3 -> (todo3'=3);
	[n3_n5!] n3>0 & dest3==5 @ c_ser3 -> (todo3'=3);
	[n3_n6!] n3>0 & dest3==6 @ c_ser3 -> (todo3'=3);
	[n3_n7!] n3>0 & dest3==7 @ c_ser3 -> (todo3'=3);
	[dep3!!] todo3==3 & n3 == 1 -> (n3'= 0)
	                             & (todo3'=0);
	[dep3!!] todo3==3 & n3  > 1 -> (n3'= n3-1)
	                             & (todo3'=2)
	                             & (c_ser3'= exponential(mu3));
endmodule


module Node4
	n4:    [0..C];
	dest4: [0..7];  // 0=out   i=Nodei for i>0
	todo4: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr4: clock;  // extern arrival ~ exponential(1.0)
	c_ser4: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr4 -> (todo4'=1) & (c_arr4'= exponential(1.0));
	[n1_n4?]    -> (todo4'=1);
	[n2_n4?]    -> (todo4'=1);
	[n3_n4?]    -> (todo4'=1);
//	[n4_n4?]    -> (todo4'=1);  // self-loop
	[n5_n4?]    -> (todo4'=1);
	[n6_n4?]    -> (todo4'=1);
	[n7_n4?]    -> (todo4'=1);
	[arr4!!] todo4==1 & n4 == 0     -> (todo4'=2)
	                                 & (n4'= n4+1)
	                                 & (c_ser4'= exponential(mu4));
	[arr4!!] todo4==1 & n4>0 & n4<C -> (todo4'=0)
	                                 & (n4'= n4+1);
	[arr4!!] todo4==1 & n4 == C     -> (todo4'=0);
	// Choose next packet destination
	[choose4!!] todo4==2 -> p4_0 : (dest4'=0) & (todo4'=0)
	                      + p4_1 : (dest4'=1) & (todo4'=0)
	                      + p4_2 : (dest4'=2) & (todo4'=0)
	                      + p4_3 : (dest4'=3) & (todo4'=0)
	                      + p4_4 : (dest4'=4) & (todo4'=0)
	                      + p4_5 : (dest4'=5) & (todo4'=0)
	                      + p4_6 : (dest4'=6) & (todo4'=0)
	                      + p4_7 : (dest4'=7) & (todo4'=0);
	// Packet service
	[n4_  !] n4>0 & dest4==0 @ c_ser4 -> (todo4'=3);
	[n4_n1!] n4>0 & dest4==1 @ c_ser4 -> (todo4'=3);
	[n4_n2!] n4>0 & dest4==2 @ c_ser4 -> (todo4'=3);
	[n4_n3!] n4>0 & dest4==3 @ c_ser4 -> (todo4'=3);
	[n4_n4!] n4>0 & dest4==4 @ c_ser4 -> (todo4'=2)  // self-loop
	                                   & (c_ser4'= exponential(mu4)); 
	[n4_n5!] n4>0 & dest4==5 @ c_ser4 -> (todo4'=3);
	[n4_n6!] n4>0 & dest4==6 @ c_ser4 -> (todo4'=3);
	[n4_n7!] n4>0 & dest4==7 @ c_ser4 -> (todo4'=3);
	[dep4!!] todo4==3 & n4 == 1 -> (n4'= 0)
	                             & (todo4'=0);
	[dep4!!] todo4==3 & n4  > 1 -> (n4'= n4-1)
	                             & (todo4'=2)
	                             & (c_ser4'= exponential(mu4));
endmodule


module Node5
	n5:    [0..C];
	dest5: [0..7];  // 0=out   i=Nodei for i>0
	todo5: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr5: clock;  // extern arrival ~ exponential(1.0)
	c_ser5: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr5 -> (todo5'=1) & (c_arr5'= exponential(1.0));
	[n1_n5?]    -> (todo5'=1);
	[n2_n5?]    -> (todo5'=1);
	[n3_n5?]    -> (todo5'=1);
	[n4_n5?]    -> (todo5'=1);
//	[n5_n5?]    -> (todo5'=1);  // self-loop
	[n6_n5?]    -> (todo5'=1);
	[n7_n5?]    -> (todo5'=1);
	[arr5!!] todo5==1 & n5 == 0     -> (todo5'=2)
	                                 & (n5'= n5+1)
	                                 & (c_ser5'= exponential(mu5));
	[arr5!!] todo5==1 & n5>0 & n5<C -> (todo5'=0)
	                                 & (n5'= n5+1);
	[arr5!!] todo5==1 & n5 == C     -> (todo5'=0);
	// Choose next packet destination
	[choose5!!] todo5==2 -> p5_0 : (dest5'=0) & (todo5'=0)
	                      + p5_1 : (dest5'=1) & (todo5'=0)
	                      + p5_2 : (dest5'=2) & (todo5'=0)
	                      + p5_3 : (dest5'=3) & (todo5'=0)
	                      + p5_4 : (dest5'=4) & (todo5'=0)
	                      + p5_5 : (dest5'=5) & (todo5'=0)
	                      + p5_6 : (dest5'=6) & (todo5'=0)
	                      + p5_7 : (dest5'=7) & (todo5'=0);
	// Packet service
	[n5_  !] n5>0 & dest5==0 @ c_ser5 -> (todo5'=3);
	[n5_n1!] n5>0 & dest5==1 @ c_ser5 -> (todo5'=3);
	[n5_n2!] n5>0 & dest5==2 @ c_ser5 -> (todo5'=3);
	[n5_n3!] n5>0 & dest5==3 @ c_ser5 -> (todo5'=3);
	[n5_n4!] n5>0 & dest5==4 @ c_ser5 -> (todo5'=3);
	[n5_n5!] n5>0 & dest5==5 @ c_ser5 -> (todo5'=2)  // self-loop
	                                   & (c_ser5'= exponential(mu5)); 
	[n5_n6!] n5>0 & dest5==6 @ c_ser5 -> (todo5'=3);
	[n5_n7!] n5>0 & dest5==7 @ c_ser5 -> (todo5'=3);
	[dep5!!] todo5==3 & n5 == 1 -> (n5'= 0)
	                             & (todo5'=0);
	[dep5!!] todo5==3 & n5  > 1 -> (n5'= n5-1)
	                             & (todo5'=2)
	                             & (c_ser5'= exponential(mu5));
endmodule


module Node6
	n6:    [0..C];
	dest6: [0..7];  // 0=out   i=Nodei for i>0
	todo6: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr6: clock;  // extern arrival ~ exponential(1.0)
	c_ser6: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr6 -> (todo6'=1) & (c_arr6'= exponential(1.0));
	[n1_n6?]    -> (todo6'=1);
	[n2_n6?]    -> (todo6'=1);
	[n3_n6?]    -> (todo6'=1);
	[n4_n6?]    -> (todo6'=1);
	[n5_n6?]    -> (todo6'=1);
//	[n6_n6?]    -> (todo6'=1);  // self-loop
	[n7_n6?]    -> (todo6'=1);
	[arr6!!] todo6==1 & n6 == 0     -> (todo6'=2)
	                                 & (n6'= n6+1)
	                                 & (c_ser6'= exponential(mu6));
	[arr6!!] todo6==1 & n6>0 & n6<C -> (todo6'=0)
	                                 & (n6'= n6+1);
	[arr6!!] todo6==1 & n6 == C     -> (todo6'=0);
	// Choose next packet destination
	[choose6!!] todo6==2 -> p6_0 : (dest6'=0) & (todo6'=0)
	                      + p6_1 : (dest6'=1) & (todo6'=0)
	                      + p6_2 : (dest6'=2) & (todo6'=0)
	                      + p6_3 : (dest6'=3) & (todo6'=0)
	                      + p6_4 : (dest6'=4) & (todo6'=0)
	                      + p6_5 : (dest6'=5) & (todo6'=0)
	                      + p6_6 : (dest6'=6) & (todo6'=0)
	                      + p6_7 : (dest6'=7) & (todo6'=0);
	// Packet service
	[n6_  !] n6>0 & dest6==0 @ c_ser6 -> (todo6'=3);
	[n6_n1!] n6>0 & dest6==1 @ c_ser6 -> (todo6'=3);
	[n6_n2!] n6>0 & dest6==2 @ c_ser6 -> (todo6'=3);
	[n6_n3!] n6>0 & dest6==3 @ c_ser6 -> (todo6'=3);
	[n6_n4!] n6>0 & dest6==4 @ c_ser6 -> (todo6'=3);
	[n6_n5!] n6>0 & dest6==5 @ c_ser6 -> (todo6'=3);
	[n6_n6!] n6>0 & dest6==6 @ c_ser6 -> (todo6'=2)  // self-loop
	                                   & (c_ser6'= exponential(mu6)); 
	[n6_n7!] n6>0 & dest6==7 @ c_ser6 -> (todo6'=3);
	[dep6!!] todo6==3 & n6 == 1 -> (n6'= 0)
	                             & (todo6'=0);
	[dep6!!] todo6==3 & n6  > 1 -> (n6'= n6-1)
	                             & (todo6'=2)
	                             & (c_ser6'= exponential(mu6));
endmodule


module Node7
	n7:    [0..C];
	dest7: [0..7];  // 0=out   i=Nodei for i>0
	todo7: [0..3];  // 0=idle  1=arrival  2=choose  3=departure
	c_arr7: clock;  // extern arrival ~ exponential(1.0)
	c_ser7: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ c_arr7 -> (todo7'=1) & (c_arr7'= exponential(1.0));
	[n1_n7?]    -> (todo7'=1);
	[n2_n7?]    -> (todo7'=1);
	[n3_n7?]    -> (todo7'=1);
	[n4_n7?]    -> (todo7'=1);
	[n5_n7?]    -> (todo7'=1);
	[n6_n7?]    -> (todo7'=1);
//	[n7_n7?]    -> (todo7'=1);  // self-loop
	[arr7!!] todo7==1 & n7 == 0     -> (todo7'=2)
	                                 & (n7'= n7+1)
	                                 & (c_ser7'= exponential(mu7));
	[arr7!!] todo7==1 & n7>0 & n7<C -> (todo7'=0)
	                                 & (n7'= n7+1);
	[arr7!!] todo7==1 & n7 == C     -> (todo7'=0);
	// Choose next packet destination
	[choose7!!] todo7==2 -> p7_0 : (dest7'=0) & (todo7'=0)
	                      + p7_1 : (dest7'=1) & (todo7'=0)
	                      + p7_2 : (dest7'=2) & (todo7'=0)
	                      + p7_3 : (dest7'=3) & (todo7'=0)
	                      + p7_4 : (dest7'=4) & (todo7'=0)
	                      + p7_5 : (dest7'=5) & (todo7'=0)
	                      + p7_6 : (dest7'=6) & (todo7'=0)
	                      + p7_7 : (dest7'=7) & (todo7'=0);
	// Packet service
	[n7_  !] n7>0 & dest7==0 @ c_ser7 -> (todo7'=3);
	[n7_n1!] n7>0 & dest7==1 @ c_ser7 -> (todo7'=3);
	[n7_n2!] n7>0 & dest7==2 @ c_ser7 -> (todo7'=3);
	[n7_n3!] n7>0 & dest7==3 @ c_ser7 -> (todo7'=3);
	[n7_n4!] n7>0 & dest7==4 @ c_ser7 -> (todo7'=3);
	[n7_n5!] n7>0 & dest7==5 @ c_ser7 -> (todo7'=3);
	[n7_n6!] n7>0 & dest7==6 @ c_ser7 -> (todo7'=3);
	[n7_n7!] n7>0 & dest7==7 @ c_ser7 -> (todo7'=2)  // self-loop
	                                   & (c_ser7'= exponential(mu7)); 
	[dep7!!] todo7==3 & n7 == 1 -> (n7'= 0)
	                             & (todo7'=0);
	[dep7!!] todo7==3 & n7  > 1 -> (n7'= n7-1)
	                             & (todo7'=2)
	                             & (c_ser7'= exponential(mu7));
endmodule


properties
	S[ 60:3000 ]( n7 >= L )
//	S[ 60:30000 ]( n7 >= L )
endproperties
