/*
 * Seven-nodes queueing network for the FIG tool
 * Budde | 2019
 *
 * {-
 * Jackson seven-nodes network:
 * 
 *     __________TO____________ ____
 *    |   n1 n2 n3 n4 n5 n6 n7 | out|
 *    |n1 .1 .1 .1 .1 .2 .2  0 | .2 |  Probabilities
 *  F |n2 .1 .1 .1 .1 .2 .2  0 | .2 |  transition-matrix
 *  R |n3 .1 .1 .1 .1 .2 .2  0 | .2 |  of the seven nodes
 *  O |n4 .1 .1 .1 .1 .2 .2  0 | .2 |
 *  M |n5 .1 .1 .1 .1  0 .1 .3 | .2 |
 *    |n6 .1 .1 .1 .1 .1  0 .3 | .2 |
 *    |n7 .1 .1 .1 .1 .1 .1 .2 | .2 |
 *    +------------------------+----+
 *
 * All nodes {1,2,...,7} have assumed infinite capacity
 * New packets arrive and can leave from all nodes ("in parallel"):
 *  - external arrivals follow an exponential distribution with rate 1
 *  - a packet served in node i (at rate mu_i) makes a probabilistic choice:
 *    --> with probability 0.2 it leaves the system
 *    --> with the probabilities of the transition-matrix it goes to another node
 * Overall arrival rate at nodes: n1=n2=n3=n4:l_a ; n5=n6:l_b ; n7:l_c
 * Service rates of the nodes: n1=n2=n3=n4:mu_a < n5=n6:mu_b < n7:mu_c
 * Loads of the nodes: n1=n2=n3=n4:rho_a > n5=n6:rho_b > n7:rho_c
 * The 'load' of node i is: (1+in_other_nodes)/mu_i == l_x/mu_x
 *
 * Rare events: target node n7 reaching a predefined limiting capacity 'L'
 * Stopping events (for transient analysis): n7 becoming empty
 * Initial state: ni=0 for i=1,2,...,6; n7=1
 * 
 * NOTE: for the event to be rare and interesting
 *       it is important that lower-number nodes have heavier loads,
 *       i.e. rho_a > rho_b > rho_c ("earlier nodes serve packets slowlier")
 * -}
 */


// Values taken from "RESTART vs. Splitting: A comparative study,"
// Jose Villen-Altamirano, Performance Evaluation 121-122 (2018) 38-47

const int L = 30;    // Queue limiting capacity
const int c = L+99;  // Queues real capacity (mimic infinite size)
const float l_a = 4.5;
const float l_b = 5.73;
const float l_c = 5.55;
const int mu_a =  9;
const int mu_b = 14;
const int mu_c = 17;
const float l1 = l_a;    // overall arrival rate at node n1
const float l2 = l_a;    // overall arrival rate at node n2
const float l3 = l_a;    // overall arrival rate at node n3
const float l4 = l_a;    // overall arrival rate at node n4
const float l5 = l_b;    // overall arrival rate at node n5
const float l6 = l_b;    // overall arrival rate at node n6
const float l7 = l_c;    // overall arrival rate at node n7
const float mu1 = mu_a;  //         service rate at node n1
const float mu2 = mu_a;  //         service rate at node n2
const float mu3 = mu_a;  //         service rate at node n3
const float mu4 = mu_a;  //         service rate at node n4
const float mu5 = mu_b;  //         service rate at node n5
const float mu6 = mu_b;  //         service rate at node n6
const float mu7 = mu_c;  //         service rate at node n7

// Importance function used in the aforementioned article:
//   0.23*(n1+n2+n3+n4) + 0.45*(n5+n6) + n7
// Importance function used for fig:
//   23*(n1+n2+n3+n4) + 45*(n5+n6) + 100*n7
// Thresholds used in the article: all importance values from 2-32,
//                                 with splitting == 3 for all except
//                                 2,3,32 which have splitting == 2
//                                 and 19 which has splitting == 4
// Thresholds used for fig: "200:2,300:2,400:3,500:3,600:3,700:3,800:3,900:3,1000:3,1100:3,1200:3,1300:3,1400:3,1500:3,1600:3,1700:3,1800:3,1900:4,2000:3,2100:3,2200:3,2300:3,2400:3,2500:3,2600:3,2700:3,2800:3,2900:3,3000:3,3100:3,3200:2"

// Transition matrix probabilities:
// column 1:
const float p1_1 = 0.1;
const float p2_1 = 0.1;
const float p3_1 = 0.1;
const float p4_1 = 0.1;
const float p5_1 = 0.1;
const float p6_1 = 0.1;
const float p7_1 = 0.1;
// column 2:
const float p1_2 = 0.1;
const float p2_2 = 0.1;
const float p3_2 = 0.1;
const float p4_2 = 0.1;
const float p5_2 = 0.1;
const float p6_2 = 0.1;
const float p7_2 = 0.1;
// column 3:
const float p1_3 = 0.1;
const float p2_3 = 0.1;
const float p3_3 = 0.1;
const float p4_3 = 0.1;
const float p5_3 = 0.1;
const float p6_3 = 0.1;
const float p7_3 = 0.1;
// column 4:
const float p1_4 = 0.1;
const float p2_4 = 0.1;
const float p3_4 = 0.1;
const float p4_4 = 0.1;
const float p5_4 = 0.1;
const float p6_4 = 0.1;
const float p7_4 = 0.1;
// column 5:
const float p1_5 = 0.2;
const float p2_5 = 0.2;
const float p3_5 = 0.2;
const float p4_5 = 0.2;
const float p5_5 = 0.0;
const float p6_5 = 0.1;
const float p7_5 = 0.1;
// column 6:
const float p1_6 = 0.2;
const float p2_6 = 0.2;
const float p3_6 = 0.2;
const float p4_6 = 0.2;
const float p5_6 = 0.1;
const float p6_6 = 0.0;
const float p7_6 = 0.1;
// column 7:
const float p1_7 = 0.0;
const float p2_7 = 0.0;
const float p3_7 = 0.0;
const float p4_7 = 0.0;
const float p5_7 = 0.3;
const float p6_7 = 0.3;
const float p7_7 = 0.2;
// column out:
const float p1_0 = 0.2;
const float p2_0 = 0.2;
const float p3_0 = 0.2;
const float p4_0 = 0.2;
const float p5_0 = 0.2;
const float p6_0 = 0.2;
const float p7_0 = 0.2;


module Node1
	n1:      [0..c];
	dest:    [0..7];
	choose:    bool init false;
	arrival:   bool init false;
	departure: bool init false;
	clk_arr: clock;  // extern arrival ~ exponential(1.0)
	clk_ser: clock;  // packet service ~ exponential(mu1)
	//
	// Packet arrival, from the exterior or from another node
	[] @ clk_arr -> (arrival'=true);
//	[n1_n1?]     -> (arrival'=true);  // self-loop
	[n2_n1?]     -> (arrival'=true);
	[n3_n1?]     -> (arrival'=true);
	[n4_n1?]     -> (arrival'=true);
	[n5_n1?]     -> (arrival'=true);
	[n6_n1?]     -> (arrival'=true);
	[n7_n1?]     -> (arrival'=true);
	[arr1!!] arrival & n1 == 0     -> (n1'= n1+1) & (choose'=true)
	                                & (clk_arr'= exponential(1.0))
	                                & (clk_ser'= exponential(mu1))
	                                & (arrival'=false);
	[arr1!!] arrival & n1>0 & n1<c -> (n1'= n1+1)
	                                & (clk_arr'= exponential(1.0))
	                                & (arrival'=false);
	[arr1!!] arrival & n1 == c     -> (clk_arr'= exponential(1.0))
	                                & (arrival'=false);
	// Choose next packet destination
	[choose1!!] choose -> p1_0 : (dest'=0) & (choose'=false)
	                    + p1_1 : (dest'=1) & (choose'=false)
	                    + p1_2 : (dest'=2) & (choose'=false)
	                    + p1_3 : (dest'=3) & (choose'=false)
	                    + p1_4 : (dest'=4) & (choose'=false)
	                    + p1_5 : (dest'=5) & (choose'=false)
	                    + p1_6 : (dest'=6) & (choose'=false)
	                    + p1_7 : (dest'=7) & (choose'=false);
	// Packet service
	[      ] dest==0 @ clk_ser -> (departure'=true);
	[n1_n1!] dest==1 @ clk_ser -> (clk_ser'= exponential(mu1));  // self
	[n1_n2!] dest==2 @ clk_ser -> (departure'=true);
	[n1_n3!] dest==3 @ clk_ser -> (departure'=true);
	[n1_n4!] dest==4 @ clk_ser -> (departure'=true);
	[n1_n5!] dest==5 @ clk_ser -> (departure'=true);
	[n1_n6!] dest==6 @ clk_ser -> (departure'=true);
	[n1_n7!] dest==7 @ clk_ser -> (departure'=true);
	[n1_dep!!] departure & n1 == 1 -> (n1'= n1-1)
	                                & (departure'=false);
	[n1_dep!!] departure & n1  > 1 -> (n1'= n1-1)
	                                & (departure'=false)
	                                & (clk_ser'= exponential(mu1));
endmodule

module Node2
	n2:      [0..c];
	dest:    [0..7];
	choose:    bool init false;
	arrival:   bool init false;
	departure: bool init false;
	clk_arr: clock;  // extern arrival ~ exponential(1.0)
	clk_ser: clock;  // packet service ~ exponential(mu2)
	//
	// Packet arrival, from the exterior or from another node
	[] @ clk_arr -> (arrival'=true);
	[n1_n2?]     -> (arrival'=true);
//	[n2_n2?]     -> (arrival'=true);  // self-loop
	[n3_n2?]     -> (arrival'=true);
	[n4_n2?]     -> (arrival'=true);
	[n5_n2?]     -> (arrival'=true);
	[n6_n2?]     -> (arrival'=true);
	[n7_n2?]     -> (arrival'=true);
	[arr2!!] arrival & n2 == 0     -> (n2'= n2+1) & (choose'=true)
	                                & (clk_arr'= exponential(1.0))
	                                & (clk_ser'= exponential(mu2))
	                                & (arrival'=false);
	[arr2!!] arrival & n2>0 & n2<c -> (n2'= n2+1)
	                                & (clk_arr'= exponential(1.0))
	                                & (arrival'=false);
	[arr2!!] arrival & n2 == c     -> (clk_arr'= exponential(1.0))
	                                & (arrival'=false);
	// Choose next packet destination
	[choose2!!] choose -> p2_0 : (dest'=0) & (choose'=false)
	                    + p2_1 : (dest'=1) & (choose'=false)
	                    + p2_2 : (dest'=2) & (choose'=false)
	                    + p2_3 : (dest'=3) & (choose'=false)
	                    + p2_4 : (dest'=4) & (choose'=false)
	                    + p2_5 : (dest'=5) & (choose'=false)
	                    + p2_6 : (dest'=6) & (choose'=false)
	                    + p2_7 : (dest'=7) & (choose'=false);
	// Packet service
	[      ] dest==0 @ clk_ser -> (departure'=true);
	[n2_n1!] dest==1 @ clk_ser -> (departure'=true);
	[n2_n2!] dest==2 @ clk_ser -> (clk_ser'= exponential(mu2));  // self
	[n2_n3!] dest==3 @ clk_ser -> (departure'=true);
	[n2_n4!] dest==4 @ clk_ser -> (departure'=true);
	[n2_n5!] dest==5 @ clk_ser -> (departure'=true);
	[n2_n6!] dest==6 @ clk_ser -> (departure'=true);
	[n2_n7!] dest==7 @ clk_ser -> (departure'=true);
	[n2_dep!!] departure & n2 == 1 -> (n2'= n2-1)
	                                & (departure'=false);
	[n2_dep!!] departure & n2  > 1 -> (n2'= n2-1)
	                                & (departure'=false)
	                                & (clk_ser'= exponential(mu2));
endmodule



properties
  S[ 60:30000 ]( n2 >= L )
endproperties
