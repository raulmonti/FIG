/*
 * Three queue tandem network for the FIG tool
 * Budde | 2019
 *
 * {-
 * Jackson three-tandem queue network:
 * 
 *           q1             q2             q3
 * ---> [..@@@@] ----> [....@@] ----> [....@@] ---->
 *  a             b1             b2             b3
 *
 * All queues (q1,q2,q3) have assumed infinite capacity
 * New packets arrive at q1 following an exponential distribution with rate a
 * Packets in q1 are served at rate b1 (exponential distribution) and sent to q2
 * Packets in q2 are served at rate b2 (exponential distribution) and sent to q3
 * Packets in q3 are served at rate b3 (exponential distribution) and leave
 * The 'load' of queue qi is: a/bi
 *
 * Rare events: q3 reaching a predefined limiting capacity 'L'
 * Stopping events (for transient analysis): q3 becoming empty
 * Initial state: q1=q2=0, q3=1
 * 
 * NOTE: for the event to be rare and interesting
 *       it is important that each queue is a bottleneck of the next,
 *       i.e. mu1 < mu2 < mu3 ("earlier queues serve packets slowlier")
 * -}
 */

// Values taken from "RESTART vs. Splitting: A comparative study,"
// Jose Villen-Altamirano, Performance Evaluation 121-122 (2018) 38-47

const int L = 14;      // Queue limiting capacity
const int c = L+99;    // Queues real capacity (mimic infinite size)
const int alpha = 2;   // rate(--> q1                  )
const int beta1 = 3;   // rate(    q1 --> q2           )
const int beta2 = 4;   // rate(           q2 --> q3    )
const int beta3 = 6;   // rate(                  q3 -->)

// Importance function used in the aforementioned article: 0.37*q1 + 0.63*q2 + q3
// Importance function used for fig: 37*q1 + 63*q2 + 100*q3
// Thresholds used in the article: all importance values from 2-29,
//                                 with splitting as given for fig below.
// Thresholds used for fig: "200:2,300:2,400:2,500:2,600:2,700:3,800:2,900:3,1000:2,1100:3,1200:3,1300:2,1400:3,1500:3,1600:3,1700:2,1800:3,1900:3,2000:3,2100:2,2200:3,2300:3,2400:3,2500:3,2600:3,2700:2,2800:6,2900:5"


module Arrivals
        clk0: clock;  // External arrivals ~ Exponential(a)
        [P0!] @ clk0 -> (clk0'= exponential(alpha));
endmodule

module Queue1
        q1: [0..c];
        clk1: clock;  // Queue1 processing ~ Exponential(b1)
        // Packet arrival
        [P0?] q1 == 0          -> (q1'= q1+1) & (clk1'= exponential(beta1));
        [P0?] q1  > 0 & q1 < c -> (q1'= q1+1);
        [P0?] q1 == c          -> ;
        // Packet processing
        [P1!] q1 == 1 @ clk1 -> (q1'= q1-1);
        [P1!] q1  > 1 @ clk1 -> (q1'= q1-1) & (clk1'= exponential(beta1));
endmodule

module Queue2
        q2: [0..c];
        clk2: clock;  // Queue2 processing ~ Exponential(b2)
        // Packet arrival
        [P1?] q2 == 0          -> (q2'= q2+1) & (clk2'= exponential(beta2));
        [P1?] q2  > 0 & q2 < c -> (q2'= q2+1);
        [P1?] q2 == c          -> ;
        // Packet processing
        [P2!] q2 == 1 @ clk2 -> (q2'= q2-1);
        [P2!] q2  > 1 @ clk2 -> (q2'= q2-1) & (clk2'= exponential(beta2));
endmodule

module Queue3
        q3: [0..c];
        clk3: clock;  // Queue3 processing ~ Exponential(b3)
        // Packet arrival
        [P2?] q3 == 0          -> (q3'= q3+1) & (clk3'= exponential(beta3));
        [P2?] q3  > 0 & q3 < c -> (q3'= q3+1);
        [P2?] q3 == c          -> ;
        // Packet processing
        [P3!] q3 == 1 @ clk3 -> (q3'= q3-1);
        [P3!] q3  > 1 @ clk3 -> (q3'= q3-1) & (clk3'= exponential(beta3));
endmodule


properties
	S[ 60:30000 ]( q3 >= L )  // "rate with time-bound"
//	S( q3 >= L )  // "rate"
//	S( (q1 >= c/2 & q2 >= L) | q3 >= L )  // "rate"
endproperties
