/*
 * Tandem queue for the FIG tool
 * Budde, Monti, D'Argenio | 2016
 *
 * {-
 * Stochastic tandem queue concept:
 *
 *   'P0'       (q1)   'P1'      (q2)   'P2'
 * -------> [..@@@@] ------> [....@@] ------>
 *  lambda             mu1              mu2
 *
 * 'P0' tells a new packet arrives at q1    (clock 'clk0')
 * 'P1' tells a packet passes from q1 to q2 (clock 'clk1')
 * 'P2' tells a packet exits q2             (clock 'clk2')
 * 
 * Property type: TRANSIENT ("probability of rare event before stop event")
 *                RATE      ("steady-state probability of rare event")
 * Rare events: packets bouncing on q2
 * Stopping events (TRANSIENT): q2 becoming empty
 * Reference events (RATE): any system transition
 * Initial state: Queue1 empty, Queue2 holds 1 packet
 * Initial clocks: clk0, clk2
 * -}
 */



// One-liners:
// $ fig this/file/path --parlare 1 --stop-conf .8 .4 --timeout 3s -e restart -t es --acomp 'Queue1+5*Queue2'
// $ fig this/file/path --parlare 1 --stop-conf .8 .4 --timeout 3s -e restart -t es --acomp 'Queue1+5*Queue2' --time-factor 'clkTO/10.0'
//
// Time factor functions:
// - linear decay:      clkTO/TIME_LIMIT
// - log decay:         log(clkTO)/log(TIME_LIMIT)
// - inverse log decay: 1.0-log(TIME_LIMIT-clkTO)/log(TIME_LIMIT)



// Values taken from Marnix Garvels' PhD Thesis:
// "The splitting method in rare event simulation", p. 85.

const int c = 8;		// Queues capacity
const int lambda = 3;	// rate(--> q1           )
const int    mu1 = 2;	// rate(    q1 --> q2    )
const int    mu2 = 6;	// rate(           q2 -->)

// The following values are in p. 61 of the same work:
// const int lambda = 1;
// const int    mu1 = 4;
// const int    mu2 = 2;


//  Queues  ///////////////////////////////////////////////////////////////////

module Arrivals
        clk0: clock;  // External arrivals ~ Exponential(lambda)
        [P0!] @ clk0 -> (clk0'= exponential(lambda));
endmodule

module Queue1
        q1: [0..c];
        clk1: clock;  // Queue1 processing ~ Exponential(mu1)
        // Packet arrival
        [P0?] q1 == 0          -> (q1'= q1+1) & (clk1'= exponential(mu1));
        [P0?] q1  > 0 & q1 < c -> (q1'= q1+1);
        [P0?] q1 == c          -> ;
        // Packet processing
        [P1!] q1 == 1 @ clk1 -> (q1'= q1-1);
        [P1!] q1  > 1 @ clk1 -> (q1'= q1-1) & (clk1'= exponential(mu1));
endmodule

module Queue2
        q2: [0..c] init 1;
        clk2: clock;  // Queue2 processing ~ Exponential(mu2)
        // Packet arrival
        [P1?] q2 == 0          -> (q2'= q2+1) & (clk2'= exponential(mu2));
        [P1?] q2  > 0 & q2 < c -> (q2'= q2+1);
        [P1?] q2 == c          -> ;
        // Packet processing
        [P2!] q2 == 1 @ clk2 -> (q2'= q2-1);
        [P2!] q2  > 1 @ clk2 -> (q2'= q2-1) & (clk2'= exponential(mu2));
endmodule


//  Timer  /////////////////////////////////////////////////////////////////////

const float TIME_LIMIT = 10.0; 

module Timer
        TimeOut: [0..2] init 0;  // init (0) --> ticking (1) --> expired (2)
        clkTO: clock;
        [TOinit!!] TimeOut == 0 -> (TimeOut'=1) & (clkTO'=dirac(TIME_LIMIT));
        [TO!] TimeOut == 1 @ clkTO -> (TimeOut'=2);
endmodule


//  Properties  ////////////////////////////////////////////////////////////////

properties
	P(      q2 > 0 U q2 == c )  // "transient"
	P( TimeOut < 2 U q2 == c )  // "reliability," aka "time-bounded transient"
endproperties
