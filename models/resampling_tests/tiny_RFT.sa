// Tests for conditional (re)sampling of clocks
// Budde, Monti, D'Argenio | 2021
//
// Fault tree with repairs: AND(L, OR(M1,M2), R)
// Repair priority (decreasing): L, M2, M1, R.
// Galileo:
//   toplevel "System";
//   "System" and "L" "M" "R";
//   "M" or "M1" "M2";
//   "L"  EXT_failPDF=normal(174.0,18.0) EXT_repairPDF=lognormal(2.458,0.2325);
//   "R"  EXT_failPDF=normal(202.0,19.1) EXT_repairPDF=lognormal(2.458,0.2325);
//   "M1" EXT_failPDF=exponential(3.01)  EXT_repairPDF=erlang(3,4.27);
//   "M2" EXT_failPDF=exponential(3.13)  EXT_repairPDF=erlang(4,4.27);
//   "RBOX" repairbox_priority "L" "M2" "M1" "R";
//
// Sample command line:
// $ fig --parlare 1 --dft 0 --stop-time 1m --rng-seed 909250341 -e restart --thresholds-adhoc "1:3,2:6" --acomp 'BE_0+max(BE_1,BE_2)+BE_4;0;3' tiny_RFT.sa
//
// Compare against flag "--no-resampling"


// Type: Basic event; Original name: L; Assigned unique id: 0
module BE_0
  fc_0 : clock;
  rc_0 : clock;
  inform_0 : [0..2] init 0;
  brokenFlag_0 : [0..2] init 0;

  [] brokenFlag_0==0 @ fc_0 -> (inform_0'=1) & (brokenFlag_0'=1);
  [r_0??] brokenFlag_0==1 -> (brokenFlag_0'=2) & (rc_0'=lognormal(2.458,0.2325));
  [] brokenFlag_0==2 @ rc_0 -> (inform_0'=2) & (brokenFlag_0'=0) & (fc_0'=normal(174.0,18.0));
  
  [f_0!!] inform_0==1 -> (inform_0'=0);
  [u_0!!] inform_0==2 -> (inform_0'=0);
endmodule

// Type: Basic event; Original name: M1; Assigned unique id: 1
module BE_1
  fc_1 : clock;
  rc_1 : clock;
  inform_1 : [0..2] init 0;
  brokenFlag_1 : [0..2] init 0;

  [] brokenFlag_1==0 @ fc_1 -> (inform_1'=1) & (brokenFlag_1'=1);
  [r_1??] brokenFlag_1==1 -> (brokenFlag_1'=2) & (rc_1'=erlang(3,4.27));
  [] brokenFlag_1==2 @ rc_1 -> (inform_1'=2) & (brokenFlag_1'=0) & (fc_1'=exponential(3.01));
  
  [f_1!!] inform_1==1 -> (inform_1'=0);
  [u_1!!] inform_1==2 -> (inform_1'=0);
endmodule

// Type: Basic event; Original name: M2; Assigned unique id: 2
module BE_2
  fc_2 : clock;
  rc_2 : clock;
  inform_2 : [0..2] init 0;
  brokenFlag_2 : [0..2] init 0;

  [] brokenFlag_2==0 @ fc_2 -> (inform_2'=1) & (brokenFlag_2'=1);
  [r_2??] brokenFlag_2==1 -> (brokenFlag_2'=2) & (rc_2'=erlang(4,4.27));
  [] brokenFlag_2==2 @ rc_2 -> (inform_2'=2) & (brokenFlag_2'=0) & (fc_2'=exponential(3.13));

  [f_2!!] inform_2==1 -> (inform_2'=0);
  [u_2!!] inform_2==2 -> (inform_2'=0);
endmodule

// Type: OR gate; Original name: M; Assigned unique id: 3
module OR_3
  informf_3: bool init false;
  informu_3: bool init false;
  count_3: [0..2] init 0;

  [f_1??] count_3==0 -> (count_3'=1) & (informf_3'=true);
  [f_1??] count_3==1 -> (count_3'=2);
  [f_2??] count_3==0 -> (count_3'=1) & (informf_3'=true);
  [f_2??] count_3==1 -> (count_3'=2);

  [u_1??] count_3==1 -> (count_3'=0) & (informu_3'=true);
  [u_1??] count_3==2 -> (count_3'=1);
  [u_2??] count_3==1 -> (count_3'=0) & (informu_3'=true);
  [u_2??] count_3==2 -> (count_3'=1);

  [f_3!!] informf_3 & count_3>0 -> (informf_3'=false);
  [u_3!!] informu_3 & count_3==0 -> (informu_3'=false);
endmodule

// Type: Basic event; Original name: R; Assigned unique id: 4
module BE_4
  fc_4 : clock;
  rc_4 : clock;
  inform_4 : [0..2] init 0;
  brokenFlag_4 : [0..2] init 0;

  [] brokenFlag_4==0 @ fc_4 -> (inform_4'=1) & (brokenFlag_4'=1);
  [r_4??] brokenFlag_4==1 -> (brokenFlag_4'=2) & (rc_4'=lognormal(2.458,0.2325));
  [] brokenFlag_4==2 @ rc_4 -> (inform_4'=2) & (brokenFlag_4'=0) & (fc_4'=normal(202.0,19.1));
  
  [f_4!!] inform_4==1 -> (inform_4'=0);
  [u_4!!] inform_4==2 -> (inform_4'=0);
endmodule

// Type: AND gate; Original name: System; Assigned unique id: 5
module AND_5
  informf_5: bool init false;
  informu_5: bool init false;
  count_5: [0..3] init 0;

  [f_0??] count_5==0 -> (count_5'=1);
  [f_0??] count_5==1 -> (count_5'=2);
  [f_0??] count_5==2 -> (count_5'=3) & (informf_5'=true);
  [f_3??] count_5==0 -> (count_5'=1);
  [f_3??] count_5==1 -> (count_5'=2);
  [f_3??] count_5==2 -> (count_5'=3) & (informf_5'=true);
  [f_4??] count_5==0 -> (count_5'=1);
  [f_4??] count_5==1 -> (count_5'=2);
  [f_4??] count_5==2 -> (count_5'=3) & (informf_5'=true);

  [u_0??] count_5==1 -> (count_5'=0);
  [u_0??] count_5==2 -> (count_5'=1);
  [u_0??] count_5==3 -> (count_5'=2) & (informu_5'=true);
  [u_3??] count_5==1 -> (count_5'=0);
  [u_3??] count_5==2 -> (count_5'=1);
  [u_3??] count_5==3 -> (count_5'=2) & (informu_5'=true);
  [u_4??] count_5==1 -> (count_5'=0);
  [u_4??] count_5==2 -> (count_5'=1);
  [u_4??] count_5==3 -> (count_5'=2) & (informu_5'=true);

  [f_5!!] informf_5 & count_5==3 -> (informf_5'=false);
  [u_5!!] informu_5 & count_5<3 -> (informu_5'=false);
endmodule

//Type: Repair box with priority policy; Original name: RBOX; Assigned unique id: 6
module RBOX_6
  brokenFlag_6[4]: bool init false;
  busy_6: bool init false;

  [f_0??] -> (brokenFlag_6[0]'=true);
  [f_2??] -> (brokenFlag_6[1]'=true);
  [f_1??] -> (brokenFlag_6[2]'=true);
  [f_4??] -> (brokenFlag_6[3]'=true);

  [r_0!!] !busy_6 & fsteq(brokenFlag_6,true) == 0 -> (busy_6'=true);
  [r_2!!] !busy_6 & fsteq(brokenFlag_6,true) == 1 -> (busy_6'=true);
  [r_1!!] !busy_6 & fsteq(brokenFlag_6,true) == 2 -> (busy_6'=true);
  [r_4!!] !busy_6 & fsteq(brokenFlag_6,true) == 3 -> (busy_6'=true);

  [u_0??] -> (brokenFlag_6[0]'=false) & (busy_6'=false);
  [u_2??] -> (brokenFlag_6[1]'=false) & (busy_6'=false);
  [u_1??] -> (brokenFlag_6[2]'=false) & (busy_6'=false);
  [u_4??] -> (brokenFlag_6[3]'=false) & (busy_6'=false);

endmodule


const float t_limit = 150.0; 

module ReliabilityTimer
  ReliabilityTimeOut: [0..2] init 0;
  clkTO: clock;
  [TOinit!!] ReliabilityTimeOut == 0 -> (ReliabilityTimeOut'=1) & (clkTO'=dirac(t_limit));
  [] ReliabilityTimeOut==1 @ clkTO -> (ReliabilityTimeOut'=2);
endmodule

properties
  P( ReliabilityTimeOut<2 U count_5==3 )  // Reliability @ t_limit
  //S( count_5==3 )                         // Availability
endproperties

// Compositional importance function for FIG tool:
// BE_0+max(BE_1,BE_2)+BE_4;0;3
